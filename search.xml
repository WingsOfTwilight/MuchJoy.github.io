<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql—redo日志&amp;undo日志</title>
      <link href="/2024/07/22/Mysql%E2%80%94redo%E6%97%A5%E5%BF%97-undo%E6%97%A5%E5%BF%97/"/>
      <url>/2024/07/22/Mysql%E2%80%94redo%E6%97%A5%E5%BF%97-undo%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/../images/%E8%AF%BB%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E8%BF%87%E7%A8%8B.png"></p><blockquote><p>undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC。<br>redo log（重做日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复。<br>binlog （归档日志）：是 Server 层生成的日志，主要用于数据备份和主从复制。</p></blockquote><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>undo log（回滚日志），它保证了事务的 ACID 特性 (opens new window)中的原子性（Atomicity）。undo log日志是一种用于撤回的日志。在事务没提交之前，mysql会先记录更新前的数据到undo log日志里。当事务会滚时，可以利用undo log回滚。如下图<br><img src="/../images/undo.png"></p><p>在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。</p><p>不同的操作，需要记录的内容也是不同的，所以不同类型的操作（修改、删除、新增）产生的 undo log 的格式也是不同的，具体的每一个操作的 undo log 的格式我就不详细介绍了，感兴趣的可以自己去查查。</p><p>一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：</p><blockquote><p>通过 trx_id 可以知道该记录是被哪个事务修改的；<br>通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；</p></blockquote><p>undo log 还有一个作用，通过 ReadView + undo log 实现 MVCC（多版本并发控制）。</p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>前面讲到过Buffer Pool，提高了读写效率。但是问题来了，Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</p><h3 id="为什么需要redo-log"><a href="#为什么需要redo-log" class="headerlink" title="为什么需要redo log?"></a>为什么需要redo log?</h3><p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，这个时候更新就算完成了。</p><p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是** WAL （Write-Ahead Logging）**技术。</p><p>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。</p><p><img src="/../images/redo.png"></p><p>开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。</p><p><strong>不过，在内存修改该 Undo 页面后，需要记录对应的 redo log。</strong></p><p><strong>redo log 记录了此次事务「完成后」的数据状态，记录的是更新之后的值；</strong><br><strong>undo log 记录了此次事务「开始前」的数据状态，记录的是更新之前的值；</strong></p><p>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务，如下图：<br><img src="/../images/%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%89%8D%E5%90%8E.png"></p><p>所以有了 redo log，再通过 WAL 技术，InnoDB 就可以保证即使数据库发生异常重启，之前已提交的记录都不会丢失，这个能力称为 <strong>crash-safe（崩溃恢复）</strong>。可以看出来， redo log 保证了事务四大特性中的<strong>持久性</strong>。</p><p>写入 redo log 的方式使用了追加操作， 所以磁盘操作是顺序写，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写。</p><p>磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。</p><p>实际上， 执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I/O 操作，而且磁盘的运行速度远慢于内存。</p><p>所以，redo log 也有自己的缓存—— redo log buffer，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘。</p><h3 id="为什么需要两阶段提交？"><a href="#为什么需要两阶段提交？" class="headerlink" title="为什么需要两阶段提交？"></a>为什么需要两阶段提交？</h3><p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现<strong>半成功的状态</strong>，这样就造成两份日志之间的逻辑不一致。</p><p>举个例子，假设 id = 1 这行数据的字段 name 的值原本是 ‘jay’，然后执行 UPDATE t_user SET name = ‘xiaolin’ WHERE id = 1; 如果在持久化 redo log 和 binlog 两个日志的过程中，出现了半成功状态，那么就有两种情况：</p><p>1、<strong>如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而 binlog 还没有来得及写入</strong>。MySQL 重启后，通过 redo log 能将 Buffer Pool 中 id = 1 这行数据的 name 字段恢复到新值 xiaolin，但是 binlog 里面没有记录这条更新语句，在主从架构中，binlog 会被复制到从库，由于 binlog 丢失了这条更新语句，从库的这一行 name 字段是旧值 jay，与主库的值不一致性；<br>2、<strong>如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redo log 还没有来得及写入</strong>。由于 redo log 还没写，崩溃恢复以后这个事务无效，所以 id = 1 这行数据的 name 字段还是旧值 jay，而 binlog 里面记录了这条更新语句，在主从架构中，binlog 会被复制到从库，从库执行了这条更新语句，那么这一行 name 字段是新值 xiaolin，与主库的值不一致性；</p><p>可以看到，在持久化 redo log 和 binlog 这两份日志的时候，如果出现半成功的状态，就会造成主从环境的数据不一致性。这是因为 redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。</p><p><strong>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决</strong>。两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p><p><strong>两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」</strong>。</p><p>当客户端执行 commit 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，<strong>分两阶段来完成 XA 事务的提交</strong>，如下图：<br><img src="/../images/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png"></p><p>从图中可看出，事务的提交过程有两个阶段，就是<strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog</strong>,具体如下：</p><p>1、<strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）；</p><p>2、<strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql—事务</title>
      <link href="/2024/07/22/Mysql%E2%80%94%E4%BA%8B%E5%8A%A1/"/>
      <url>/2024/07/22/Mysql%E2%80%94%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h3><p>A原子性：不存在中间状态，要么全做，要么全不做。<br>I隔离性：针对某些数据库操作来说，不仅要保证操作以原子性的方式进行，而且还要保证其他的状态转换不会影响到本次状态转换。<br>C一致性：数据库自身可以保证一部分一致性需求，比如表建立主键，唯一索引等。 更多的一致性需要靠写业务代码的程序员自己保证。<br>D持久性：当一个状态转换完成后，这个妆换的结果永久保留。</p><p><img src="/../images/%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png"></p><h3 id="事务语法"><a href="#事务语法" class="headerlink" title="事务语法"></a>事务语法</h3><blockquote><p>BEGIN[WORK] 表示开启了一个失误。WORK可有可无。</p><blockquote><p>BEGIN;<br>加入事务的语句…</p></blockquote></blockquote><blockquote><p>START TRANSACTION与BEGIN语句有相同的功效。start transaction可以跟随几个修饰符。<br>REA ONLY：表示当前事务是一个只读事务。<br>READ WRITE: 表示当前事务是一个读写事务。<br>WITH CONSISTEND SNAPASHOT: 启动一致性读</p><blockquote><p>1、START TRANSACTION;<br>加入事务的语句…<br>2、START TRANSACTION READ ONLY;</p></blockquote></blockquote><blockquote><p>COMMIT [WORK];提交事务</p><blockquote><p>BEGIN;<br>加入事务的语句…<br>COMMIT;</p></blockquote></blockquote><blockquote><p>ROLLBACK [WORK];会滚事务</p><blockquote><p>BEGIN;<br>加入事务的语句…<br>ROLLBACK;</p></blockquote></blockquote><blockquote><p>SAVEPOINT 保存点名称</p><blockquote><p>1、当想回滚到某个保存点时，可以使用下面语句：<br>ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称。<br>2、如果想删除某个保存点<br>RELEASE SAVEPOINT 保存点名称；</p></blockquote></blockquote><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>read uncommitted ：读未提交； 可能发生 <strong>脏读</strong>，<strong>不可重复度</strong>，<strong>幻读</strong><br>read committed ：读已提交；可能发生 <strong>不可重复度</strong>，<strong>幻读</strong><br>repeatable read ：可重复读；可能发生 <strong>幻读</strong><br>serializable ：序列化；上述现象都不可能发生。</p><blockquote><p>脏写：如果一个事务修改了另一个未提交的事物修改过的数据，就意味着发生了脏写。<br>脏读：如果一个事务读到了另一个未提交事务修改过的数据，就意味着发生了脏读。<br>不可重复度：如果一个事务修改了另一个未提交事务读区的数据，就意味着发生了不可重复度。（是在一个事务内，连续两次读取<strong>同一</strong>数据集，发现两次读取的数据内容不一致。）<br>幻读：在一个事务在读取数据时，另一事务插入或删除了数据，导致第一次读取的数据与第二次读取的数据不一致，尽管读取的<strong>条件没有改变</strong>。（条件没有变，结果集改变了）</p></blockquote><h3 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h3><p>trx_id：一个事务每次对某条<strong>聚簇索引</strong>记录进行改动时，都会吧事务的事务id赋值给trx_id隐藏列。<br>roll_pointer：每次对某条<strong>聚簇索引</strong>记录进行改动时，都会把旧版本写入undo日志中，这个隐藏列就相当于一个指针，可以通过它找到该记录修改前的信息。</p><p>每次更新记录后，都会将旧值放到一条undo日志中，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，这个链表称为版本链。版本链的头节点就是当前记录的最新值。<strong>另外每个版本中还包含生成该版本时对应的事务id</strong>。之后会利用这个记录的版本链来控制并发事务访问相同记录时的行为，这种机制称为<strong>多版本并发控制 MVCC</strong>。</p><p>对于read uncommitted隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取最新的版本记录就可以了。<br>对于serializable隔离级别的事务，使用了加锁的方式来访问记录。<br>对于read committed 和repeatable read隔离级别的事务来说，都必须保证读到已经提交的事务修改过的记录。核心的问题就是：<strong>需要判断版本链中的那个版本是当前事务可见的</strong>。InnoDB提出<strong>ReadView</strong>一致性视图的概念。</p><blockquote><p>1、m_ids：再生成ReadView时，当前系统中活跃的读写事务的事务id列表。<br>2、min_trx_id：在生成ReadView时，当前系统中活跃的读写事务中最小的事务id;也就是m_ids中最小的。<br>3、max_trx_id：再生成ReadView时，系统应该分配给下一个事务的事务id值。<br>4、creator_trx_id：生成该ReadView的事务的事务id。</p></blockquote><p>只有在对表中的记录进行改动时，才会为事务分配唯一的事务id，否则一个事务的id值都是默认为0。</p><p>判断记录的某个版本是否可见：</p><blockquote><p>1、如果被访问版本的trx_id与ReadView中的creator_trx_id相同，就意味着事务在访问他自己修改过的记录，所以该版本是可以被当前事务访问的。<br>2、如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。<br>3、如果被访问的trx_id大于或等于ReadView中的max_trx_id，表明生成该版本的事务在当前事务生成ReadView后才开启的，所以该版本不可能被当前事务访问。<br>4、如果被访问版本的trx_id在ReadView的min_trx_id和max_trx_id之间，则需要判断trx_id是否在m_ids中，如果在，则说明创建ReadView时生成的该本本的事务还是活跃的，该版本不可以被访问；如果不在，就说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</p></blockquote><p>read committed 每次读取数据前都生成一个ReadView。<br>repeatable read 在第一次读取数据时生成一个readView。</p><h3 id="二级索引与MVCC"><a href="#二级索引与MVCC" class="headerlink" title="二级索引与MVCC"></a>二级索引与MVCC</h3><p>只有聚簇索引中才有trx_id和roll_pointer隐藏列。二级索引如何判断可见性呢？</p><blockquote><p>步骤1、二级索引页面的page header部分有一个PAGE_MAX_TRX_ID属性，每当对该页面中的记录执行增删改操作时，如果执行该操作的事务的事务id大于PAGE_MAX_TRX_ID属性值，就会吧page_max_trx_id属性设置为执行该操作的事务的事务id。这就意味着page_max_trx_id的属性值就代表修改二级索引页面的最大事务id是什么，之后，就可以判断赌赢的ReadView的min_trx_id是否大于该页面的page_max_trx_id的值，如果是，则页面中所有记录可见。否则执行步骤二，再回表之后再判断。<br>步骤2、利用二级索引记录中的主键值进行回表操作，得到对应的聚簇索引记录之后在按照前面的方式找到对应的ReadView可见的第一个版本。然后判断该版本中相应的二级索引的值是否与利用该二级索引查询时的值相同。如果是就把记录发送给客户端，如果不是，就跳过该记录。</p></blockquote><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>并发事务访问相同记录的情况大致可以划分为3种：<br>1、读-读，本身对记录没有影响。所以允许发生这种情况。<br>2、写-写，并发事务相继对相同的记录进行改动。<br>3、写-读，读-写：也就是说一个事务进行读取操作，另一个事务进行改动操作。</p><h3 id="锁定读"><a href="#锁定读" class="headerlink" title="锁定读"></a>锁定读</h3><p><strong>共享锁和独占锁</strong><br>共享锁：简称S锁，在事务要读取一条记录时，需要先获取该记录的S锁。<br>独占锁：也称为排它锁，简称X锁，在事务要改动一条记录时，需要先获取该记录的X锁。</p><p>S锁和S锁是兼容的，S锁和X锁是不兼容的，X锁和X锁是不是兼容的。</p><blockquote><p>对读取的记录加S锁：select * from table lock in share mode;<br>对读取的记录加X锁：select * from table for update;</p></blockquote><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p>平常所用到的写操作无非是DELETE，UPDATE，INSERT这3种。</p><blockquote><p>DELETE：对一条记录进行DELETE操作的过程就是先在B+树中定位到这条记录的位置，然后获取这条记录的X锁，最后在执行delete mark操作。</p></blockquote><blockquote><p>UPDATE：对一条记录进行UPDATE操作时分为下面3种情况。</p><blockquote><p>1、如果未修改该记录的键值 并且被更新的列所占用的存储空间在修改前后未发生变化，则，现在B+树中定位到这条记录的位置，然后获取记录的X锁，最后再原记录的位置进行修改操作。<br>2、如果未修改该记录的键值 并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在B+树中定位到这条记录的位置，然后获取记录的X锁，之后将该记录彻底删除掉（把记录彻底移入垃圾链表）最后插入一条新记录。<br>3、如果修改了该记录的键值，则相当于在原记录上执行力DELETE操作之后再进行一次INSERT操作，加锁操作就需要按照DELETE和INSERT的规则进行了。</p></blockquote></blockquote><blockquote><p>INSERT：一般情况下，新插入一条记录受隐式锁保护，不需要在内存中为其生成对应的锁结构。</p></blockquote><h3 id="InnoDb的行级锁"><a href="#InnoDb的行级锁" class="headerlink" title="InnoDb的行级锁"></a>InnoDb的行级锁</h3><p><strong>1、Record Lock</strong> ：记录锁，官方命名：LOCK_REC_NOT_GAP,这种记录锁有S型和X型之分。<br><strong>2、Gap Lock</strong> ：在Repeatable read隔离级别下可以很大程度上解决幻读现象，解决方案有2种：1、使用MVCC方案解决；2、使用加锁方案解决。</p><blockquote><p>但是使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，无法给这些记录加上记录锁。所以InnoDB提出了Gap Lock锁。</p></blockquote><p><strong>间隙锁是指锁住一个索引记录的前间隙，而不是锁住具体的索引记录。间隙锁的目的是防止其他事务在该间隙内插入新的记录，从而避免幻读现象。</strong></p><p>gap锁的提出仅仅是为了防止插入幻影记录而提出的。</p><p><strong>对于最后一条记录之后的间隙</strong> 给那条记录加gap锁才能阻止其他事物在（8，+∞）插入新的记录呢？为了阻止其他事物在（8，+∞）区间插入记录，可以给最后一条记录所在的页面的supremum记录加上一个gap锁。</p><p><strong>3、Next-Key Lock</strong> ：既想锁住某条记录，又想阻止其他事务在该记录前面的间隙加入新的记录。本质就是一个Record锁+gap锁组合体。</p><blockquote><p>Insert Intention Lock，一个事务在插入一条记录时，需要判断插入位置是否已经被别的事物加入了gap锁。如果有，插入操作需要等待，直到拥有gap锁的那个事务提交为止。事务在等待时也需要在内存中生成一个锁接口，表明有事务想在某个间隙插入新记录，但是现在处于等待状态。这种类型的锁为Insert Intention Lock，也被称为插入意向锁。</p></blockquote><h3 id="锁定读的语句"><a href="#锁定读的语句" class="headerlink" title="锁定读的语句"></a>锁定读的语句</h3><blockquote><p>1、语句1:select …… LOCK IN SHARE MODE;<br>2、语句2:select …… for update;<br>3、语句3:update ……<br>4、语句4:delete ……</p></blockquote><p>语句1和语句2是mysql中规定的2中锁定读的语法格式，而语句3和语句4由于在执行过程中需要首先定位到被改动的记录并给记录加锁，也可以认为一种锁定读。</p><p><strong>匹配模式</strong>：执行查询时，查询优化器会生成若干个扫描区间。在扫描区间内快速定位到第一条记录。然后沿着这条记录所在的单项链表可以访问到其他数据。<br><strong>唯一性搜索</strong>：如果在扫描某个扫描区间的记录前，就能事先确定该扫描区间内最多只包含一条记录的话，那么就把这种情况称为唯一性搜索。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql—Explain</title>
      <link href="/2024/07/13/Mysql%E2%80%94Explain/"/>
      <url>/2024/07/13/Mysql%E2%80%94Explain/</url>
      
        <content type="html"><![CDATA[<p><img src="/../images/explain.png"></p><h2 id="EXPLAIN-执行计划"><a href="#EXPLAIN-执行计划" class="headerlink" title="EXPLAIN(执行计划)"></a>EXPLAIN(执行计划)</h2><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><blockquote><p>无论语句多么复杂，到最后也是对每个表进行单表访问。该条记录的table列代表该表的表名。</p></blockquote><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><blockquote><p>1、每出现一个select关键字，都会分配一个唯一的id。但是连接查询的执行计划中，每个表都会对应以一条记录，但是这些记录的id值都是相通的。出现前面的表是驱动表，出现在后面的表是被驱动表。<br>2、UNION子句查询，id出现为空的记录，是因为需要把结果集进行去重，从而使用了临时表，id为NULL表示这个临时表是为了合并结果集创建的。</p></blockquote><h3 id="select-types"><a href="#select-types" class="headerlink" title="select_types"></a>select_types</h3><blockquote><p>1、SIMPLE : 查询语句中不包含UNION或者子查询的查询都算作SIMPLE类型,连接查询也是SIMPLE。<br>2、PRIMARY : 对于大查询来说，它是由几个小查询组成，其中最左边的那个查询的select_type值就是PRIMARY。<br>3、UNION : 对于大查询来说，它是由几个小查询组成，其中最左边的那个查询的select_type值是PRIMARY之外，其余小的查询就是UNION。<br>4、UNION RESULT : mysql选择使用临时表来完成UNION查询的去重工作，针对该临时表的查询的select_type就是UNION RESULT。<br>5、SUBQUERY : 如果包含的子查询语句不能够转为对应的半连接形式，并且该子查询是不相关子查询。而且查询优化器决定将子查询物化的方案来执行该子查询时。此时那个子查询的select_type就是SUBQUERY。<br>6、DEPENDENT SUBQUERY : 如果包含的子查询语句不能够转为对应的半连接形式，并且该子查询被查询优化器转为相关子查询的形式，此时那个子查询的select_type就是DEPENDENT SUBQUERY。<br>7、DEPENDENT UNION : 在包涵UNION或者UNION ALL的大查询中，如果各个小查询都依赖外层查询，处理最小的查询外，其他查询都是DEPENDENT UNION。<br>8、DERIVED : 在包涵派生表的查询中，如果是以物化派生表的查询方式，派生表对应的字查询的select_type就是DERIVED。<br>9、MATERIALIZED : 当查询器优化执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询，该子查询的select_type就是MATERIALIZED。</p></blockquote><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><blockquote><p>1、system : 当表中只有一条记录并且该表使用的存储引擎（MyISAM，MEMORY）的统计数据是精确的。<br>2、const:根据主键或者唯一二级索引列与常数进行等值匹配时，对单表访问的方法就是const。<br>3、eq_ref:执行连接查询时，被驱动表是通过主键或者不允许为NULL的唯一二级索引列等值匹配的方式进行访问的。则对被驱动表的访问方法就是er_ref。<br>4、ref : 通过普通的二级索引列与常量进行等值匹配的方式来查询某个表时。<br>5、fulltext : 全文检索<br>6、ref_of_null : 对普通二级索引进行等值匹配且该索引列的值也可以是NULL值时。<br>7、index_merge : 使用索引合并的方式对某个表执行查询的。<br>8、range:使用索引获取某些单点<strong>扫描区间</strong>的记录。<br>9、index:使用索引覆盖，但需要扫描全部索引记录时。<br>10、ALL : 全表扫描</p></blockquote><h3 id="possible-keys-和-key"><a href="#possible-keys-和-key" class="headerlink" title="possible_keys 和 key"></a>possible_keys 和 key</h3><blockquote><p>possible_keys 列表示在某个查询语句中，对某个表执行单表查询时可能用的到索引；key列表示实际用到的索引。<br>⚠️ possible_keys列中的值并不是越多越好，可以使用的索引越多，查询优化器在计算查询成本时话费的时间就越长。</p></blockquote><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><blockquote><p>执行计划的rows列就代表预计扫描的索引记录行数。</p></blockquote><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>条件过滤</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><blockquote><p>1、No table used ：语句中没有from子句<br>2、Impossible WHERE：查询语句的WHERE条件永远为false时<br>3、No matching min/max row :当查询列表有MIN或MAX聚集函数时，当时并没有记录符合WHERE子句中的搜索条件时。<br>4、Using index:使用覆盖索引执行查询时。</p></blockquote><blockquote><p>5、Using index condition:搜索条件中出现了索引列，但却不能充当边界条件来形成扫描区间。</p><blockquote><p>select * from s1 where key1&gt;’z’ and key1 like ‘%a’;key1字段为索引字段。执行步骤：<br>1、定位到key1&gt;’z’的第一条二级索引记录。此时不回表查询：先判断key1&gt;’z’ and key1 like ‘%a’是否成立。如果不成立直接找下一条记录。如果成立，则执行回表操作。<br>2、然后再判断其他查询条件（该例子中没有出key1之外的条件）<br>3、之后继续循环执行1，2 </p></blockquote></blockquote><blockquote><p>6、Using where:当某个搜索条件需要在server层判断。不是通过索引直接过滤，是通过where条件过滤<br>7、Using join buffer(Block Nested Loop):在连接查询时，被驱动表不能有效利用索引加快访问速度时，mysql一般会为其分配名连接缓冲区的内存快 加快查询速度。也就是基于块嵌套循环算法来执行连接查询。<br>8、Using intersect(···)，Using union(···)，Using sort_union(···) ：说明准备使用索引合并的方式查询。<br>9、Zero limit ：当limit子句的参数为0时。压根儿不打算查出数据。<br>10、Using filesort:对结果集中的记录进行排序时，是可以使用到索引的。排序在内存或者磁盘中进行的（文件排序）。</p></blockquote><blockquote><p>11、Using temporary :在执行DISTINCT，GROUP BY，UNION等子句查询时，如果不能有效的利用索引，muysql很可能通过建立内部的临时表来执行查询。GROUP BY</p><blockquote><p>GROUP BY会默认进行order by操作，如果不使用默认的可以 order by NULL<br>select common_field,count(*) as amount from s1 group by common_field order by null</p></blockquote></blockquote><blockquote><p>12、Start temporary ,End temporary:将in转化为半连接时，执行策略为Duplicate Weedout时。也就是通过建立临时表来为外层查询中的记录进行去重操作时，驱动表的查询执行计划的Extra列将显示Start temporary，被驱动表查询执行计划的Extra列将显示End temporary。<br>13、LooseScan：再将in子查询转为半连接时，如果采用的是LooseScan执行策略，则驱动表执行计划的extra列就显示LooseScan提示。<br>14、FirstMatch（tableName）再将in子查询转为半连接时，如果采用的是FirstMatch执行策略，则驱动表执行计划的extra列就显示FirstMatch（tableName）提示。</p></blockquote><h2 id="Buffer-Pool-缓冲池"><a href="#Buffer-Pool-缓冲池" class="headerlink" title="Buffer Pool(缓冲池)"></a>Buffer Pool(缓冲池)</h2><p>为了缓存磁盘中的页，mysql服务器在启动的时候像操作系统申请了一片连续的内存————buffer pool。默认Buffer Pool是一个实例。可以设置innodb_buffer_pool_instances来修改Buffer Pool实例的个数。当innodb_buffer_pool_size的值小于1GB是，设置多个实例是无效的。mysql5.7.5之后，buffer pool 是有若干个chunk组成。一个chunk就代表一片连续的内存空间，里面包含了若干个缓冲页与其对应的控制块。</p><h3 id="Buffer-Pool组成"><a href="#Buffer-Pool组成" class="headerlink" title="Buffer Pool组成"></a>Buffer Pool组成</h3><p>buffer pool 对应的连续的内存被划分为若干个页面，页面大小与InnoDB表空间用的页面大小一致，默认16kb。这些页面被称为缓冲页。控制信息占用的一块内存称为一个控制块。控制块与缓存页一一对应。<br><img src="/../images/BufferPoll.png"></p><h3 id="free链表"><a href="#free链表" class="headerlink" title="free链表"></a>free链表</h3><p>把所有空闲的缓冲页对应的控制块作为一个节点放到一个链表中，这个链表就是free链表（空闲列表）。刚完成初始化的Buffer Pool中，所有的缓冲页都是空闲的。所有的缓冲页对应的控制块都会加入到free链表中。</p><p><img src="/../images/free%E9%93%BE%E8%A1%A8.png"></p><h3 id="flush链表"><a href="#flush链表" class="headerlink" title="flush链表"></a>flush链表</h3><p>当修改了Buffer Pool中的某个缓冲页的数据，它就与磁盘中的页不一致了，这样的缓冲页被称为<strong>脏页</strong>。 凡是被修改过的缓存页对应的控制块都会作为一个节点加入到链表中。这个链表中的节点对应的缓冲页都需要被刷新到磁盘中，所以也别称为<strong>flush链表</strong>。flush链表与free链表类似。</p><p><strong>刷新脏页到磁盘</strong>：后台有专门的线程负责每隔一段时间就把脏页面刷新到磁盘中。</p><blockquote><p>1、从LRU链表中的冷数据中刷新一部分到磁盘。<br>2、从flush链中刷新一部分页面到磁盘中。</p></blockquote><h3 id="LRU链表"><a href="#LRU链表" class="headerlink" title="LRU链表"></a>LRU链表</h3><p>LRU链表按照一定的<strong>比例</strong>分成两截：一部分存储使用频率比较高的缓冲页，这部分链表被称为<strong>热数据</strong>；另外一部分存储使用频率不是很高的缓冲页，这部分链表也称为<strong>冷数据</strong>。<br>查看：</p><blockquote><p>show variables like ‘innode_old_blocks_pct’</p></blockquote><p>配置：</p><blockquote><p>set GLOBAL innodb_old_blocks_pct = 40</p></blockquote><p>针对LRU链表还有很多优化策略。优化的目的：尽量高效的提高Buffer Pool命中率。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis详解四</title>
      <link href="/2024/07/11/Mybatis%E8%AF%A6%E8%A7%A3%E5%9B%9B/"/>
      <url>/2024/07/11/Mybatis%E8%AF%A6%E8%A7%A3%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="动态sql原理"><a href="#动态sql原理" class="headerlink" title="动态sql原理"></a>动态sql原理</h2><p>SqlNode接口,简单理解就是xml中的每个标签，比如上述sql的update,trim,if标签：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface SqlNode {</span><br><span class="line">    boolean apply(DynamicContext context);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/../images/sqlNode.png"></p><p>SqlSource Sql源接口，代表从xml文件或注解映射的sql内容，主要就是用于创建BoundSql，有实现类DynamicSqlSource(动态Sql源)，StaticSqlSource(静态Sql源)等.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface SqlSource {</span><br><span class="line"></span><br><span class="line">  BoundSql getBoundSql(Object parameterObject);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/../images/sqlSource.png"></p><p>BoundSql类，封装mybatis最终产生sql的类，包括sql语句，参数，参数源数据等参数：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class BoundSql {</span><br><span class="line"></span><br><span class="line">  private final String sql;</span><br><span class="line">  private final List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line">  private final Object parameterObject;</span><br><span class="line">  private final Map&lt;String, Object&gt; additionalParameters;</span><br><span class="line">  private final MetaObject metaParameters;</span><br></pre></td></tr></tbody></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>MyBatis插件机制允许开发者通过自定义拦截器（interceptors）来扩展MyBatis的功能。这种机制使得开发者可以在SQL语句执行的各个阶段插入自己的逻辑，如日志记录、性能监控、动态修改SQL语句等。</p><h3 id="插件机制的基本概念"><a href="#插件机制的基本概念" class="headerlink" title="插件机制的基本概念"></a>插件机制的基本概念</h3><p>mybatis插件机制的核心是Intercepter接口，该接口定义了一个intercept方法，用于拦截并处理mybatis的四种核心对象的执行过程。</p><blockquote><p>1、Executor：负责执行增删改查的语句。<br>2、ParameterHandler：负责处理传入的参数并将其转为JDBC所需要的格式。<br>3、ResultSetHandler：负责将JDBC返回的结果集转为java对象。<br>4、SatementHandler：负责准备sql语句并将参数设置到sql语句中。</p></blockquote><h3 id="插件的创建"><a href="#插件的创建" class="headerlink" title="插件的创建"></a>插件的创建</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Intercepts({</span><br><span class="line">    @Signature(type = Executor.class, method = "update", args = {MappedStatement.class, Object.class}),</span><br><span class="line">    @Signature(type = Executor.class, method = "query", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})</span><br><span class="line">})</span><br><span class="line">public class MyInterceptor implements Interceptor {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable {</span><br><span class="line">        // 在方法执行前进行操作</span><br><span class="line">        System.out.println("Before method execution");</span><br><span class="line"></span><br><span class="line">        Object returnValue = invocation.proceed();</span><br><span class="line"></span><br><span class="line">        // 在方法执行后进行操作</span><br><span class="line">        System.out.println("After method execution");</span><br><span class="line"></span><br><span class="line">        return returnValue;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object plugin(Object target) {</span><br><span class="line">        return Plugin.wrap(target, this);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setProperties(Properties properties) {</span><br><span class="line">        // 设置插件属性</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">之后需要在mybatis配置文件中注册插件</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin interceptor="com.example.MyInterceptor"&gt;</span><br><span class="line">        &lt;property name="someProperty" value="value"/&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>所有的拦截器都要实现</p><blockquote><p>Object intercept(Invocation invocation) ：是拦截器的核心部分；用于拦截目标对象的方法调用，允许开发者在目标方法前后插入自定义逻辑。<br>plugin(Object target)：主要是将目标对象（如何Execute等mybatis的核心组件）包装成代理对象，从而能够拦截其方法调用。<br>setProperties(Properties properties)：用于接受并设置插件的配置属性，通常在配置文件中指定，并通过properties对象传递。</p></blockquote><p><strong>interceptorChain.pluginAll()</strong> 会遍历所有的拦截器</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {</span><br><span class="line">  ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">  parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">  return parameterHandler;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span><br><span class="line">    ResultHandler resultHandler, BoundSql boundSql) {</span><br><span class="line">  ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">  resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">  return resultSetHandler;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {</span><br><span class="line">  StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  return statementHandler;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  public Executor newExecutor(Transaction transaction, ExecutorType executorType) {</span><br><span class="line">  executorType = executorType == null ? defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == null ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Executor executor;</span><br><span class="line">  if (ExecutorType.BATCH == executorType) {</span><br><span class="line">    executor = new BatchExecutor(this, transaction);</span><br><span class="line">  } else if (ExecutorType.REUSE == executorType) {</span><br><span class="line">    executor = new ReuseExecutor(this, transaction);</span><br><span class="line">  } else {</span><br><span class="line">    executor = new SimpleExecutor(this, transaction);</span><br><span class="line">  }</span><br><span class="line">  if (cacheEnabled) {</span><br><span class="line">    //开启缓存，会创建CachingExecutor，查询数据先从缓存找，再从数据找</span><br><span class="line">    executor = new CachingExecutor(executor);</span><br><span class="line">  }</span><br><span class="line">  executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">  return executor;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><transactionmanager type="JDBC"><!-- 这里可以添加事务管理器的配置 --></transactionmanager><h3 id="创建TransactionFactory"><a href="#创建TransactionFactory" class="headerlink" title="创建TransactionFactory"></a>创建TransactionFactory</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//解析&lt;transactionManager&gt;节点，创建对应的TransactionFactory</span><br><span class="line">  private TransactionFactory transactionManagerElement(XNode context) throws Exception {</span><br><span class="line">    if (context != null) {</span><br><span class="line">      String type = context.getStringAttribute("type");</span><br><span class="line">      Properties props = context.getChildrenAsProperties();</span><br><span class="line">      TransactionFactory factory = (TransactionFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">      factory.setProperties(props);</span><br><span class="line">      return factory;</span><br><span class="line">    }</span><br><span class="line">    throw new BuilderException("Environment declaration requires a TransactionFactory.");</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h3 id="JdbcTransaction"><a href="#JdbcTransaction" class="headerlink" title="JdbcTransaction"></a>JdbcTransaction</h3><p>JdbcTransaction是基于 JDBC（Java Database Connectivity）的事务管理机制，主要用于手动管理事务。它直接使用 JDBC API 控制事务的提交和回滚，适用于不依赖外部事务管理器的场景。</p><h3 id="ManagedTransaction"><a href="#ManagedTransaction" class="headerlink" title="ManagedTransaction"></a>ManagedTransaction</h3><p>ManagedTransaction是用于与外部事务管理器（如 Spring 或 JTA（Java Transaction API））集成的事务管理机制。在这种模式下，事务的管理由外部容器或框架处理，而不是直接通过 JDBC 控制事务。</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p><img src="/../images/%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98.png"></p><p>MyBatis的一级缓存就是使用了简单的HashMap，MyBatis只负责将查询数据库的结果存储到缓存中去， 不会去判断缓存存放的时间是否过长、是否过期。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象，Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。</p><blockquote><p>1、如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用.<br>2、如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用.<br>3、SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用</p></blockquote><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p><img src="/../images/%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.png.png"></p><p>MyBatis 二级缓存（Second Level Cache）是一个全局缓存，可以在不同的 SqlSession 之间共享缓存数据。与一级缓存（仅限于同一个 SqlSession）不同，二级缓存能够在多个SqlSession之间共享数据，提高查询效率，减少数据库访问次数.</p><p>二级缓存的作用域是 mapper namespace（映射器命名空间），即同一个 mapper 文件下的 SQL 语句共享同一个二级缓存.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- 其他配置 --&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;setting name="cacheEnabled" value="true"/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>1、执行INSERT、UPDATE、DELETE 操作会清空对应namespace的二级缓存，防止缓存数据不一致.<br>2在SqlSession关闭或提交事务后，数据才会写入二级缓存。因此，确保在事务提交后再进行下一次查询，以便利用缓存。</p></blockquote><blockquote><p>1、MyBatis支持二级缓存的总开关：全局配置变量参数cacheEnabled=true<br>2、该select语句所在的Mapper，配置了<cache> 或<cached-ref>节点，并且有效<br>3、该select语句的参数 useCache=true</cached-ref></cache></p></blockquote><blockquote><p>请注意，如果你的MyBatis使用了二级缓存，并且你的Mapper和select语句也配置使用了二级缓存，那么在执行select查询的时候，MyBatis会先从二级缓存中取输入，其次才是一级缓存，即MyBatis查询数据的顺序是：二级缓存 ———&gt; 一级缓存 ——&gt; 数据库。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 框架｜中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis—sqlSession执行流程</title>
      <link href="/2024/07/01/Mybatis%E2%80%94sqlSession%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
      <url>/2024/07/01/Mybatis%E2%80%94sqlSession%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>sqlSession的主要功能</strong></p><blockquote><p>1、执行sql语句：sqlSession允许执行sql语句，包括create,insert,update,delete。可以从xml映射文件中调用SQL语句，也可以在映射器接口中使用注解。<br>2、事务管理：sqlSession处理事务，可以使用commit(),rollback(),close()等方法来启动，提交或者回滚事物。<br>3、结果映射：将sql查询的结果映射到java对象中。映射可以在XML中定义，也可以通过注解实现。<br>4、资源管理：sqlSession帮助管理数据库连接，并确保操作完成后正确关闭。</p></blockquote><p>sqlSession是一次数据库会话，sqlSession生命周期也不是永久的。相反，每次访问数据库都需要创建sqlSession，当然sqlSession也不是执行一次，也可以执行多次，只要sqlSession会话关闭就要重新创建。</p><h2 id="获取SqlSession"><a href="#获取SqlSession" class="headerlink" title="获取SqlSession"></a>获取SqlSession</h2><p>下面我们看一下sqlSeesion是如何获取的：</p><p><img src="/../images/SqlSession.png"></p><p>首先SqlSessionFactoryBuilder读取mybatis-config.xml配置信息，然后build出来DefaultSqlSessionFactory对象。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {</span><br><span class="line">  try {</span><br><span class="line">    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">    return build(parser.parse());</span><br><span class="line">  } catch (Exception e) {</span><br><span class="line">    throw ExceptionFactory.wrapException("Error building SqlSession.", e);</span><br><span class="line">  } finally {</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    try {</span><br><span class="line">      inputStream.close();</span><br><span class="line">    } catch (IOException e) {</span><br><span class="line">      // Intentionally ignore. Prefer previous error.</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public SqlSessionFactory build(Configuration config) {</span><br><span class="line">  return new DefaultSqlSessionFactory(config);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>再通过SqlSessionFactory获取sqlSession。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {</span><br><span class="line">  Transaction tx = null;</span><br><span class="line">  try {</span><br><span class="line">    //environment包含mybatis-config.xml中的数据源，事务信息等。</span><br><span class="line">    final Environment environment = configuration.getEnvironment();</span><br><span class="line">    //获取事务工厂并创建事务。并设置隔离级别，是否自动提交</span><br><span class="line">    final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">    //创建执行器，执行sql，并与事物关联（所有的操作都是Executor完成）</span><br><span class="line">    final Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">    //创建并返回session</span><br><span class="line">    return new DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">  } catch (Exception e) {</span><br><span class="line">    closeTransaction(tx); // may have fetched a connection so lets call close()</span><br><span class="line">    throw ExceptionFactory.wrapException("Error opening session.  Cause: " + e, e);</span><br><span class="line">  } finally {</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>获取sqlSession的主要步骤：<br>1、通过mybatis-config.xml获取Environment信息。<br>2、创建事务工厂，设置隔离级别等信息。<br>3、创建Executor执行器。（<strong>实际上所有的sqlSession操作都是由executor执行</strong>）<br>4、创建sqlSession对象。</p><p>这样就可以获取到sqlSession了，即通过sqlSessionFactory调用openSession方法。<br>获取到sqlSession之后，接下来就是执行sql了。</p><h2 id="利器MapperProxy"><a href="#利器MapperProxy" class="headerlink" title="利器MapperProxy"></a>利器MapperProxy</h2><p><img src="/../images/mapperProxy.png"></p><p>获取到Sqlsession之后，会执行对应的Mapper方法 。例如：<br>StudentMapper mapper = session.getMapper(StudentMapper.class);</p><p>在mybatis中，执行dao层接口，都是通过MapperProxy代理。一起看一下是如果获取MapperProxy代理的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//SqlSession什么都不做，直接从configuration中找</span><br><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type) {</span><br><span class="line">  return configuration.getMapper(type, this);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//configuration又将任务交给mapperRegistry</span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {</span><br><span class="line">  return mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>然后又通过MapperProxyFactory来执行任务</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {</span><br><span class="line">  final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">  if (mapperProxyFactory == null) {</span><br><span class="line">    throw new BindingException("Type " + type + " is not known to the MapperRegistry.");</span><br><span class="line">  }</span><br><span class="line">  try {</span><br><span class="line">    //重点</span><br><span class="line">    return mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">  } catch (Exception e) {</span><br><span class="line">    throw new BindingException("Error getting mapper instance. Cause: " + e, e);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最终所有的事情都是有MapperProxyFactory完成</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings("unchecked")</span><br><span class="line">protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) {</span><br><span class="line">  return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public T newInstance(SqlSession sqlSession) {</span><br><span class="line">  final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">  return newInstance(mapperProxy);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="执行器Excutor"><a href="#执行器Excutor" class="headerlink" title="执行器Excutor"></a>执行器Excutor</h2><p>sqlSession只是一个门面，sqlSession对数据的操作都是有Executor完成的，Executor也是动态创建的：Executor有<strong>3种基础类型</strong>和<strong>1种缓存类型</strong></p><blockquote><p>BatchExecutor：用于批量执行sql的执行器。<br>ReuseExecutor：会重用 PreparedStatement 对象，减少预编译sql语句的开销，从而提高性能。<br>SimpleExecutor：简单的执行sql。<br>CachingExecutor：只有在开启缓存的时候才会创建，CachingExecutor会先查找缓存，如果缓存中没有，再查找数据库，再写入缓存。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Executor newExecutor(Transaction transaction, ExecutorType executorType) {</span><br><span class="line">  executorType = executorType == null ? defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == null ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Executor executor;</span><br><span class="line">  if (ExecutorType.BATCH == executorType) {</span><br><span class="line">    executor = new BatchExecutor(this, transaction);</span><br><span class="line">  } else if (ExecutorType.REUSE == executorType) {</span><br><span class="line">    executor = new ReuseExecutor(this, transaction);</span><br><span class="line">  } else {</span><br><span class="line">    executor = new SimpleExecutor(this, transaction);</span><br><span class="line">  }</span><br><span class="line">  //开启缓存，会创建CachingExecutor，查询数据先从缓存找，再从数据找</span><br><span class="line">  if (cacheEnabled) {</span><br><span class="line">    executor = new CachingExecutor(executor);</span><br><span class="line">  }</span><br><span class="line">  executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">  return executor;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="MapperProxy"><a href="#MapperProxy" class="headerlink" title="MapperProxy"></a>MapperProxy</h3><p>每个MapperProxy对应一个dao接口，那MapperProxy是如何做到的呢？来看源码！<br>所有被代理的对象访问方法都会落实到代理着的invoke方法上。在 MyBatis中，MapperProxy.invoke 方法可以被视为整个Mapper方法调用的入口点，特别是针对动态生成的Mapper接口代理对象而言。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//mapperProxy在执行的时候会触发此方法</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {</span><br><span class="line">  try {</span><br><span class="line">    if (Object.class.equals(method.getDeclaringClass())) {</span><br><span class="line">      return method.invoke(this, args);</span><br><span class="line">    } else {</span><br><span class="line">      //走到这</span><br><span class="line">      return cachedInvoker(method).invoke(proxy, method, args, sqlSession);</span><br><span class="line">    }</span><br><span class="line">  } catch (Throwable t) {</span><br><span class="line">    throw ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  //在 MyBatis中，MapperProxy.invoke 方法可以被视为整个Mapper方法调用的入口点，特别是针对动态生成的Mapper接口代理对象而言</span><br><span class="line">  @Override</span><br><span class="line">  public Object invoke(Object proxy, Method method, Object[] args, SqlSession sqlSession) throws Throwable {</span><br><span class="line">    return mapperMethod.execute(sqlSession, args);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h3 id="MapperMethod"><a href="#MapperMethod" class="headerlink" title="MapperMethod"></a>MapperMethod</h3><p>这里就是根据参数和返回类型选择不同的sqlSession方法来执行，这样mapper和sqlSession就真正的关联起来了。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public Object execute(SqlSession sqlSession, Object[] args) {</span><br><span class="line">  Object result;</span><br><span class="line">  switch (command.getType()) {</span><br><span class="line">    case INSERT: {</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">      break;</span><br><span class="line">    }</span><br><span class="line">    case UPDATE: {</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">      break;</span><br><span class="line">    }</span><br><span class="line">    case DELETE: {</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">      break;</span><br><span class="line">    }</span><br><span class="line">    case SELECT:</span><br><span class="line">      if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) {</span><br><span class="line">        executeWithResultHandler(sqlSession, args);</span><br><span class="line">        result = null;</span><br><span class="line">      } else if (method.returnsMany()) {</span><br><span class="line">        result = executeForMany(sqlSession, args);</span><br><span class="line">      } else if (method.returnsMap()) {</span><br><span class="line">        result = executeForMap(sqlSession, args);</span><br><span class="line">      } else if (method.returnsCursor()) {</span><br><span class="line">        result = executeForCursor(sqlSession, args);</span><br><span class="line">      } else {</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">        if (method.returnsOptional()</span><br><span class="line">            &amp;&amp; (result == null || !method.getReturnType().equals(result.getClass()))) {</span><br><span class="line">          result = Optional.ofNullable(result);</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      break;</span><br><span class="line">    case FLUSH:</span><br><span class="line">      result = sqlSession.flushStatements();</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      throw new BindingException("Unknown execution method for: " + command.getName());</span><br><span class="line">  }</span><br><span class="line">  if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) {</span><br><span class="line">    throw new BindingException("Mapper method '" + command.getName()</span><br><span class="line">        + " attempted to return null from a method with a primitive return type (" + method.getReturnType() + ").");</span><br><span class="line">  }</span><br><span class="line">  return result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>executor前面已经创建好了，接下来看一下SqlSession的CURD方法。选择其中一个分析一下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T selectOne(String statement) {</span><br><span class="line">  return this.selectOne(statement, null);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">private &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler) {</span><br><span class="line">  try {</span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">    //CRUD实际上是交给Excetor去处理。</span><br><span class="line">    return executor.query(ms, wrapCollection(parameter), rowBounds, handler);</span><br><span class="line">  } catch (Exception e) {</span><br><span class="line">    throw ExceptionFactory.wrapException("Error querying database.  Cause: " + e, e);</span><br><span class="line">  } finally {</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>excutor其实也只是穿了个马甲而已.接着往下看。</p><h3 id="CacheExecutor"><a href="#CacheExecutor" class="headerlink" title="CacheExecutor"></a>CacheExecutor</h3><p>CacheExecutor有一个非常重要的属性delegate，保存的是某类的普通Executor。执行数据库update操作时，它直接调用delegate的update方法，执行query方法时先尝试从cache中取值，取不到再调用delegate的查询方法，并将查询结果存入cache中。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  @Override</span><br><span class="line">  public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span><br><span class="line">      throws SQLException {</span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    if (cache != null) {</span><br><span class="line">      flushCacheIfRequired(ms);</span><br><span class="line">      if (ms.isUseCache() &amp;&amp; resultHandler == null) {</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        @SuppressWarnings("unchecked")</span><br><span class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">        if (list == null) {</span><br><span class="line">          list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">          tcm.putObject(cache, key, list); // issue #578 and #116</span><br><span class="line">        }</span><br><span class="line">        return list;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">//删除了部分代码</span><br><span class="line">      list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;</span><br><span class="line">      if (list != null) {</span><br><span class="line">        //从缓存中取</span><br><span class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">      } else {</span><br><span class="line">        //继续调用基础类型Executor</span><br><span class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure><h3 id="普通Executor"><a href="#普通Executor" class="headerlink" title="普通Executor"></a>普通Executor</h3><p>SimpleExecutor，ReuseExecutor，BatchExecutor 都是继承BaseExecutor。下面依SimpleExecutor为例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {</span><br><span class="line">  Statement stmt = null;</span><br><span class="line">  try {</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    return handler.query(stmt, resultHandler);</span><br><span class="line">  } finally {</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h3><p>Executor本质上也是将任务交给 StatementHandler来完成的。我们先看看StatementHandler是如何创建的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {</span><br><span class="line">  StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  return statementHandler;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>每次创建StatementHandler都是每次创建的StatementHandler都是RoutingStatementHandler，它只是一个分发者，他一个属性delegate用于指定用哪种具体的StatementHandler。可选的StatementHandler有SimpleStatementHandler、PreparedStatementHandler和CallableStatementHandler三种。选用哪种在mapper配置文件的每个statement里指定，默认的是PreparedStatementHandler。同时还要注意到StatementHandler是可以被拦截器拦截的，和Executor一样，被拦截器拦截后的对像是一个代理对象。</p><p>StatementHandler创建之后。ParameterHandler随着StatementHandler的创建而创建，默认的实现是DefaultParameterHandler。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">  @Override</span><br><span class="line">  public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {</span><br><span class="line">    Statement stmt = null;</span><br><span class="line">    try {</span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      return handler.query(stmt, resultHandler);</span><br><span class="line">    } finally {</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    return stmt;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void parameterize(Statement statement) throws SQLException {</span><br><span class="line">    parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//一系列的参数设置</span><br><span class="line">    @Override</span><br><span class="line">  public void setParameters(PreparedStatement ps) {</span><br><span class="line">    ErrorContext.instance().activity("setting parameters").object(mappedStatement.getParameterMap().getId());</span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">    if (parameterMappings != null) {</span><br><span class="line">      for (int i = 0; i &lt; parameterMappings.size(); i++) {</span><br><span class="line">        ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">        if (parameterMapping.getMode() != ParameterMode.OUT) {</span><br><span class="line">          Object value;</span><br><span class="line">          String propertyName = parameterMapping.getProperty();</span><br><span class="line">          if (boundSql.hasAdditionalParameter(propertyName)) { // issue #448 ask first for additional params</span><br><span class="line">            value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">          } else if (parameterObject == null) {</span><br><span class="line">            value = null;</span><br><span class="line">          } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {</span><br><span class="line">            value = parameterObject;</span><br><span class="line">          } else {</span><br><span class="line">            MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">            value = metaObject.getValue(propertyName);</span><br><span class="line">          }</span><br><span class="line">          TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">          JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">          if (value == null &amp;&amp; jdbcType == null) {</span><br><span class="line">            jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">          }</span><br><span class="line">          try {</span><br><span class="line">            typeHandler.setParameter(ps, i + 1, value, jdbcType);</span><br><span class="line">          } catch (TypeException | SQLException e) {</span><br><span class="line">            throw new TypeException("Could not set parameters for mapping: " + parameterMapping + ". Cause: " + e, e);</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h3 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  ps.execute();</span><br><span class="line">  return resultSetHandler.handleResultSets(ps);//查询结果处理</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架｜中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql—B+树</title>
      <link href="/2024/06/29/Mysql%E2%80%94B-%E6%A0%91/"/>
      <url>/2024/06/29/Mysql%E2%80%94B-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><img src="/../images/B+%E6%A0%91.png"></p><p><strong>B+树的结构</strong></p><blockquote><p>根节点：B+树的等层节点，包含键值和指向子节点的指针。<br>内部节点：位于根节点和叶子结点之间的节点，包含键值和指向字节点的指针。<br>叶子节点：B+树最底层的节点，包含所有的数据记录和下一个叶子节点的指针。</p></blockquote><p><strong>B+树的特点</strong></p><blockquote><p>1、所有的数据都存储在叶子节点上，非叶子节点只存储键值和指向字节点的指针。<br>2、顺序访问指针，每个叶子节点都包含一个指向下一个叶子节点的指针。使得B+树可以高效的进行顺序扫描。<br>3、平衡树，即从根节点到任何叶子节点的路径长度相同，从而保证了查询，插入，删除操作的时间复杂度都是O(log n).<br>4、高扇出性，由于每个节点都包含多个叶子节点，B+树的高低较低，使得磁盘I/O操作更高效。</p></blockquote><p><strong>B+树在mysql中的应用</strong></p><blockquote><p>聚簇索引：InnoDB表的主键索引实际上是一个B+树，表中的数据行按照主键的顺序存储在叶子节点中。<br>二级索引：非主键索引也是B+树结构，叶子节点存储索引列和主键值，用于快速定位数据行。</p></blockquote><h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><p>在没有索引的情况下，无论是根据主键列还是其他列的值进行查找，都只能从第一页沿着双向链表一直向下找。</p><p>InnoDB为了灵活的管理所有的目录项（目录项两个字段记录<strong>主键和页号</strong>），复用了之前的存储用户记录的数据页来存储目录项。又是如何区分目录项和用户数据的呢？还记得记录头信息中的record_type属性吗？0用来记录普通记录，2表示Infimum记录，3表示Supremum记录，1就是用来表示目录项记录的。其实目录项还会有更高级的目录项。在数据页中有一个PAGE_LEVEL属性，就代表这个数据页面在B+数据中的层级。B+树本身就是一个目录。</p><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇索引就是数据的存储方式（所有的用户记录都存储在叶子节点上）<strong>索引即数据，数据即索引</strong>。</p><blockquote><p>1、使用记录主键值的大小进行记录和排序<br>2、B+树的叶子节点存储的是完整的用户记录。</p></blockquote><h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+数据的数据都是按照主键排序的。</p><p>如果非主键列作为查询条件又该怎么办呢？那就建立在建立一个B+树，以非主键列进行排序。</p><blockquote><p>1、使用非主键列的大小进行记录和页排序。<br>2、B+树的叶子节点存储的并不是完整的用户记录(如果查询完整数据需要<strong>回表</strong>)。而是某个非主键列值 + 主键的值。<br>3、目录项记录的不再是主键+页号，而是某个非主键列+主键+页号。</p></blockquote><p>以非主键列的大小排序规则而建立的B+树需要执行<strong>回表</strong>操作才可以定位到完整的用户记录，这种B+树被称为二级索引。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>同时以多个列的大小做为排序规则建立的B+树称为联合索引。本质也是一个二级索引。比如按照C2，C3列的大小进行排序。</p><blockquote><p>1、先把各个记录和页按照C2列进行排序。<br>2、在记录的C2相同的情况下，在采用才C3列进行排序。</p></blockquote><h3 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h3><blockquote><p>1、空间上的代价：每建立一个索引，都要建立一颗B+树，每个树的节点都是一个数据页，一个数据页默认16kb，而且一颗很大的B+树有由许多数据页组成，将占用很大一片存储空间。<br>2、时间上的代价：对数据进行增删改操作时，都需要修改B+树。而且是有序的单向链表。增删改操作会对节点和记录的排序造成破坏，存储引擎需要额外的时间进行<strong>页分裂</strong>，<strong>页面回收</strong>等操作，以维护节点和记录的排序。</p></blockquote><h2 id="B-树索引应用"><a href="#B-树索引应用" class="headerlink" title="B+树索引应用"></a>B+树索引应用</h2><h3 id="扫描区间和边界条件"><a href="#扫描区间和边界条件" class="headerlink" title="扫描区间和边界条件"></a>扫描区间和边界条件</h3><p>当使用某个索引执行查询时，关键就是通过查询条件找到合适的扫描区间，然后再到对应的B+树中扫描索引列的值在这些扫描区间的记录。对扫描区间来说，仅需要通过B+树定为到该扫描区间中的第一条记录，然后就可以沿着记录所在的单向列表向后扫描，知道某条记录不符合形成该扫描区间的边界条件为止。</p><p>对于B+树索引来说，只要索引列和常数使用=，&lt;=&gt;,IN,NOT IN, IS NULL,IS NOT NULL,&gt;,&lt;,&gt;=,&lt;=,BETWEEN,!=或者LIKE操作符连接起来，就可以产生扫描区间。</p><p>LIKE操作符比较特殊，只有匹配完整的字符串或者匹配字符串前缀时才会产生合适的扫描区间。</p><h3 id="索引用于排序"><a href="#索引用于排序" class="headerlink" title="索引用于排序"></a>索引用于排序</h3><p>一般情况下，我们只能把记录加载到内存，然后再用一些排序算法在内存中对记录进行排序。有时查询结果集太大以至于无法在内存中进行排序，此时就需要暂时借助磁盘的空间来存放中间结果，在排序操作完成后再把排好序的结果返回客户端。这种在内存或者磁盘中进行排序的方式被称为<strong>文件排序</strong>。但是如果ORDER_BY字据中使用了索引列，就有可能省去了在内存或者磁盘中排序的步骤。因为索引记录本身就是按照规则排序好的。</p><blockquote><p>使用联合索引排序： ORDER BY子句后见的列的顺序也必须按照索引列的顺序。</p></blockquote><blockquote><p>1、ASC，DESC混用，不可以使用索引进行排序。<br>2、用来排序的列包含非同一个索引的列,不可以使用索引进行排序。比如order by a,b 。a属于索引index_a,b属于index_b.</p></blockquote><p><strong>回表的代价</strong> ： 每读取一条二级索引记录，都需要根据该二级索引的id值到聚簇索引中执行回表操作。如果对应的聚簇索引记录所有在的页面不在内存中，就需要将该页面从磁盘中记载到内存中，由于读取很多id值并不连续的聚簇索引记录，而且这些聚簇索引记录分布在不同的数据页面中，数据页号也毫无规律，因此会造成大量的随机I/O。</p><blockquote><p>需执行回表操作的记录数越多，就越倾向使用全表扫描；反之侧倾于使用二级索引+回表的方式。</p></blockquote><h3 id="创建和使用索引注意事项"><a href="#创建和使用索引注意事项" class="headerlink" title="创建和使用索引注意事项"></a>创建和使用索引注意事项</h3><blockquote><p>1、只为用于搜索、排序、分组的列创建索引。<br>2、当列中不重复值的个数在总记录提条数中占比很大时，才为列建立索引。<br>3、索引列的类型尽量小。<br>4、可以只为索引列前缀创建索引，以减少索引占用的存储空间。<br>5、尽量使用覆盖索引进行查询，以避免回表操作带来的性能消耗。<br>6、让索引列以列明的形式单独出现在搜索条件中<br>7、为了尽可能少的让聚簇索引发生页面分裂的情况，建议让主键拥有AUTO_INCREMENT属性（自增）。<br>8、定位并删除表中的冗余和重复索引。</p></blockquote><p><strong>覆盖索引</strong>：索引中已经包含所有需要读取的列的查询方式。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis-初始化</title>
      <link href="/2024/06/17/Mybatis%E2%80%94%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2024/06/17/Mybatis%E2%80%94%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><strong>Mybatis工作流程</strong></p><p><img src="/../images/Mybatis%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p><h2 id="mybatis初始化方式"><a href="#mybatis初始化方式" class="headerlink" title="mybatis初始化方式"></a>mybatis初始化方式</h2><p><strong>1、基于XML配置文件</strong>：基于XML配置文件的方式是将MyBatis的所有配置信息放在XML文件中，MyBatis通过加载并XML配置文件，将配置文信息组装成内部的Configuration对象。</p><p><strong>2、基于Java API</strong>：这种方式不使用XML配置文件，需要MyBatis使用者在Java代码中，手动创建Configuration对象，然后将配置参数set 进入Configuration对象中。</p><h3 id="基于XML方式"><a href="#基于XML方式" class="headerlink" title="基于XML方式"></a>基于XML方式</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 加载 MyBatis 配置文件</span><br><span class="line">String resource = "mybatis-config.xml";</span><br><span class="line">Reader reader = Resources.getResourceAsReader(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">// 获取 SqlSession</span><br><span class="line">try (SqlSession session = sqlSessionFactory.openSession()) {</span><br><span class="line">    // 获取 Mapper</span><br><span class="line">    StudentMapper mapper = session.getMapper(StudentMapper.class);</span><br><span class="line">    // 执行查询</span><br><span class="line">    Student user = mapper.selectAll().get(0);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码一共经历了三个阶段：mybatis初始化，获取SqlSession，执行SQL语句。</p><p>上述代码功能根据加载mybatis-config.xml文件，创建SqlSessionFactory对象，然后获取SqlSession，执行sql语句。而mybatis初始化就是SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);</p><p>mybatis初始化基本过程如下图：<br><img src="/../images/mybatis%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B.png"></p><p>如上图，mybatis初始化经过一下几个步骤：<br>1、调用SqlSessionFactoryBuilder对象的build(reader)方法。<br>2、SqlSessionFactoryBuilder根据传入的字符流，创建XMLConfigBuilder对象。<br>3、XMLConfigBuilder对象调用Parse()方法，创建Configuration对象。<br>4、SqlSessionFactoryBuilder根据Configuration对象创建DefaultSqlSessionFactory对象。<br>5、SqlSessionFactoryBuilder返回SqlSessionFactory供客户端使用。</p><p>相关代码如下:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {</span><br><span class="line">  try {</span><br><span class="line">    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">    return build(parser.parse());</span><br><span class="line">  } catch (Exception e) {</span><br><span class="line">    throw ExceptionFactory.wrapException("Error building SqlSession.", e);</span><br><span class="line">  } finally {</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    try {</span><br><span class="line">      inputStream.close();</span><br><span class="line">    } catch (IOException e) {</span><br><span class="line">      // Intentionally ignore. Prefer previous error.</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public SqlSessionFactory build(Configuration config) {</span><br><span class="line">  return new DefaultSqlSessionFactory(config);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>创建Configuration的过程</strong></p><blockquote><p>parse()方法是如何处理XML文件，并生成Configuration对象的呢？</p></blockquote><p><strong>1、XMLConfigBuilder对象会将传入的XML信息转成Document对象</strong><br>而创建XPathParser对象，会创建XMLMapperEntityResolver对象(XML配置定义文件DTO)，然后将XMLMapperEntityResolver对象和Document封装到XPathParser对象中。<br>XPathParser对象会根据XPath表达是获取基本的Document节点Node信息。</p><p><strong>2、之后XMLConfigBuilder对象会调用parse()</strong><br>会从XPathParser对象中取出根节点configuration信息，然后继续获取properties，settings，typeAliases，plugins，objectFactory,objectFactory,objectWrapperFactory,reflectorFactory,environments,databaseIdProvider,typeHandlers,mappers节点信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public Configuration parse() {</span><br><span class="line">  if (parsed) {</span><br><span class="line">    throw new BuilderException("Each XMLConfigBuilder can only be used once.");</span><br><span class="line">  }</span><br><span class="line">  parsed = true;</span><br><span class="line">  parseConfiguration(parser.evalNode("/configuration"));</span><br><span class="line">  return configuration;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">private void parseConfiguration(XNode root) {</span><br><span class="line">  try {</span><br><span class="line">    // issue #117 read properties first</span><br><span class="line">    propertiesElement(root.evalNode("properties"));</span><br><span class="line">    Properties settings = settingsAsProperties(root.evalNode("settings"));</span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    loadCustomLogImpl(settings);</span><br><span class="line">    typeAliasesElement(root.evalNode("typeAliases"));</span><br><span class="line">    pluginElement(root.evalNode("plugins"));</span><br><span class="line">    objectFactoryElement(root.evalNode("objectFactory"));</span><br><span class="line">    objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));</span><br><span class="line">    reflectorFactoryElement(root.evalNode("reflectorFactory"));</span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    // read it after objectFactory and objectWrapperFactory issue #631</span><br><span class="line">    environmentsElement(root.evalNode("environments"));</span><br><span class="line">    databaseIdProviderElement(root.evalNode("databaseIdProvider"));</span><br><span class="line">    typeHandlerElement(root.evalNode("typeHandlers"));</span><br><span class="line">    mapperElement(root.evalNode("mappers"));</span><br><span class="line">  } catch (Exception e) {</span><br><span class="line">    throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>3、然后将这些信息设置到Configuration对象中</strong><br><strong>4、返回Configuration对象</strong></p><h3 id="基于Java-API"><a href="#基于Java-API" class="headerlink" title="基于Java API"></a>基于Java API</h3><p><strong>1、创建配置类</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MyBatisConfig {</span><br><span class="line">    public SqlSessionFactory getSqlSessionFactory() {</span><br><span class="line">        // 创建数据源</span><br><span class="line">        PooledDataSource dataSource = new PooledDataSource();</span><br><span class="line">        dataSource.setDriver("com.mysql.cj.jdbc.Driver");</span><br><span class="line">        dataSource.setUrl("jdbc:mysql://localhost:3306/mydatabase");</span><br><span class="line">        dataSource.setUsername("root");</span><br><span class="line">        dataSource.setPassword("password");</span><br><span class="line"></span><br><span class="line">        // 创建MyBatis配置对象</span><br><span class="line">        Configuration configuration = new Configuration();</span><br><span class="line">        configuration.setEnvironment(</span><br><span class="line">            new org.apache.ibatis.mapping.Environment(</span><br><span class="line">                "development",</span><br><span class="line">                new org.apache.ibatis.transaction.jdbc.JdbcTransactionFactory(),</span><br><span class="line">                dataSource</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 添加Mapper</span><br><span class="line">        configuration.addMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        // 构建SqlSessionFactory</span><br><span class="line">        return new SqlSessionFactoryBuilder().build(configuration);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>2、使用配置类初始化mybatis</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyBatisExample {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        // 获取SqlSessionFactory</span><br><span class="line">        MyBatisConfig config = new MyBatisConfig();</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = config.getSqlSessionFactory();</span><br><span class="line">        </span><br><span class="line">        // 使用SqlSession</span><br><span class="line">        try (SqlSession session = sqlSessionFactory.openSession()) {</span><br><span class="line">            UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">            User user = mapper.selectUser(1);</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>1、创建数据源：通过PooledDataSource创建数据源并配置数据库连接信息。<br>2、创建MyBatis配置对象：创建Configuration对象并配置环境（Environment）、事务管理器（JdbcTransactionFactory）和数据源。<br>3、添加Mapper：通过configuration.addMapper(UserMapper.class)方法将Mapper接口添加到配置中。<br>4、构建SqlSessionFactory：通过SqlSessionFactoryBuilder构建SqlSessionFactory。<br>5、使用SqlSession：通过sqlSessionFactory.openSession()获取SqlSession，并使用Mapper执行数据库操作。</p>]]></content>
      
      
      <categories>
          
          <category> 框架｜中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis—配置</title>
      <link href="/2024/06/17/Mybatis%E2%80%94%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/06/17/Mybatis%E2%80%94%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>Mybatis架构图</strong></p><p><img src="/../images/Mybatis%E6%9E%B6%E6%9E%84.png"></p><p>接口层：主要就是和数据库交互。<br>数据处理层：可以说是MyBatis 的核心，负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等，它主要的目的是根据调用的请求完成一次数据库操作。<br>mapper.xml配置sql和映射关系就是基于xml方式（基础支撑层）</p><h2 id="mybatis配置解析方法"><a href="#mybatis配置解析方法" class="headerlink" title="mybatis配置解析方法"></a>mybatis配置解析方法</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public Configuration parse() {</span><br><span class="line">  if (parsed) {</span><br><span class="line">    throw new BuilderException("Each XMLConfigBuilder can only be used once.");</span><br><span class="line">  }</span><br><span class="line">  parsed = true;</span><br><span class="line">   //configuration为根节点</span><br><span class="line">  parseConfiguration(parser.evalNode("/configuration"));</span><br><span class="line">  return configuration;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  private void parseConfiguration(XNode root) {</span><br><span class="line">  try {</span><br><span class="line">    // issue #117 read properties first</span><br><span class="line">    propertiesElement(root.evalNode("properties"));</span><br><span class="line">    Properties settings = settingsAsProperties(root.evalNode("settings"));</span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    loadCustomLogImpl(settings);</span><br><span class="line">    typeAliasesElement(root.evalNode("typeAliases"));</span><br><span class="line">    pluginElement(root.evalNode("plugins"));</span><br><span class="line">    objectFactoryElement(root.evalNode("objectFactory"));</span><br><span class="line">    objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));</span><br><span class="line">    reflectorFactoryElement(root.evalNode("reflectorFactory"));</span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    // read it after objectFactory and objectWrapperFactory issue #631</span><br><span class="line">    environmentsElement(root.evalNode("environments"));</span><br><span class="line">    databaseIdProviderElement(root.evalNode("databaseIdProvider"));</span><br><span class="line">    typeHandlerElement(root.evalNode("typeHandlers"));</span><br><span class="line">    mapperElement(root.evalNode("mappers"));</span><br><span class="line">  } catch (Exception e) {</span><br><span class="line">    throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>configuration为根节点</strong></p><h2 id="配置文件元素"><a href="#配置文件元素" class="headerlink" title="配置文件元素"></a>配置文件元素</h2><h3 id="元素properties"><a href="#元素properties" class="headerlink" title="元素properties"></a>元素properties</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--   方式一，引入外部db.properties文件 --&gt;</span><br><span class="line">&lt;properties resource="db.properties"&gt;&lt;/properties&gt;</span><br><span class="line">&lt;!--   方式二直接配置xml --&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;!-- 配置数据源 --&gt;</span><br><span class="line">    &lt;property name="driver" value="com.mysql.cj.jdbc.Driver" /&gt;</span><br><span class="line">    &lt;property name="url" value="jdbc:mysql://localhost:3306/test" /&gt;</span><br><span class="line">    &lt;property name="username" value="root" /&gt;</span><br><span class="line">    &lt;property name="password" value="123456" /&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></tbody></table></figure><p>Properties继承了Hashtable，如果同时配置2个，后加载的配置会覆盖之前的配置</p><h3 id="元素settings"><a href="#元素settings" class="headerlink" title="元素settings"></a>元素settings</h3><p>完整的setttings配置地址：<a href="https://mybatis.org/mybatis-3/zh_CN/configuration.html">https://mybatis.org/mybatis-3/zh_CN/configuration.html</a></p><h2 id="Mapper-xml文件配置"><a href="#Mapper-xml文件配置" class="headerlink" title="Mapper.xml文件配置"></a>Mapper.xml文件配置</h2><h3 id="元素cache-ref"><a href="#元素cache-ref" class="headerlink" title="元素cache-ref"></a>元素cache-ref</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace="com.read.mapper.StudentMapper"&gt;</span><br><span class="line">  &lt;!--两个 Mapper 文件将共享相同的缓存实现，避免了重复定义缓存配置的问题。--&gt;</span><br><span class="line">  &lt;cache-ref namespace="com.example.mapper.UserMapper"/&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="元素cache"><a href="#元素cache" class="headerlink" title="元素cache"></a>元素cache</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  当 blocking 属性设置为 true 时，MyBatis 使用的缓存实现（如 Ehcache）会在缓存失效时阻塞其他并发请求，</span><br><span class="line">  直到第一个线程重新查询并更新缓存，从而避免大量请求同时打到数据库上。--&gt;</span><br><span class="line">&lt;cache flushInterval="缓存刷新间隔" size="缓存的大小" eviction="缓存淘汰策略"</span><br><span class="line">       readOnly="缓存是否只读"  type="缓存类型"&gt;</span><br><span class="line">  &lt;property name="blocking" value="true"/&gt;</span><br><span class="line">&lt;/cache&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="元素resultMap"><a href="#元素resultMap" class="headerlink" title="元素resultMap"></a>元素resultMap</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">type:映射到java对象类型</span><br><span class="line">autoMapping: 是否自动映射未明确指定的字段，如果为False，只会映射resultMap中配置的字段，为True会尝试自动映射resultMap中没有配置的字段</span><br><span class="line">--&gt;</span><br><span class="line">&lt;resultMap id="studentMap" type="com.read.model.Student" autoMapping = "true"&gt;</span><br><span class="line">  &lt;!--</span><br><span class="line">    如果字段名与列名不一致，可以使用column（列名）和property（java对象字段名）</span><br><span class="line">    如果需要类型转换，可以使用 javaType（Java类型） 和 jdbcType（jdbc类型） 属性</span><br><span class="line">  --&gt;</span><br><span class="line">  &lt;result column="SId" jdbcType="VARCHAR" property="sid" /&gt;</span><br><span class="line">  &lt;result column="Sname" jdbcType="VARCHAR" property="sname" /&gt;</span><br><span class="line">  &lt;result column="Sage" jdbcType="TIMESTAMP" property="sage" /&gt;</span><br><span class="line">  &lt;result column="Ssex" jdbcType="VARCHAR" property="ssex" /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!--</span><br><span class="line">      typeHandler：处理类型转换，自定义转换类将数据库列值转换java对象字段值，或者将java对象字段值专程数据库列值</span><br><span class="line">      &lt;result column="example" property="example"  typeHandler="org.example.StringTrimTypeHandler"/&gt;</span><br><span class="line">  --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- columnPrefix 用于指定列名前缀。这在处理多表查询结果时非常有用，可以避免列名冲突 --&gt;</span><br><span class="line">  &lt;association property="address" javaType="org.example.Address" columnPrefix="address_"&gt;</span><br><span class="line">      &lt;id property="id" column="address_id"/&gt;</span><br><span class="line">      &lt;result property="street" column="address_street"/&gt;</span><br><span class="line">  &lt;/association&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- composites 用于定义复合列。复合列用于多个列值共同组成一个字段的值 --&gt;</span><br><span class="line">   &lt;result property="fullName" column="{first_name=firstName, last_name=lastName}" composites="true"/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="元素resultSet"><a href="#元素resultSet" class="headerlink" title="元素resultSet"></a>元素resultSet</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--resultSet + Collection 返回结果集：再student对象中定义List&lt;Course&gt;属性--&gt;</span><br><span class="line">    &lt;resultMap id="studentMap1" type="com.read.model.Student"&gt;</span><br><span class="line">    &lt;collection property="courses" ofType = "com.read.model.Course" resultSet="courses"&gt;</span><br><span class="line">      &lt;result column="CId" jdbcType="VARCHAR" property="cid" /&gt;</span><br><span class="line">      &lt;result column="Cname" jdbcType="VARCHAR" property="cname" /&gt;</span><br><span class="line">      &lt;result column="TId" jdbcType="VARCHAR" property="tid" /&gt;</span><br><span class="line">    &lt;/collection&gt;</span><br><span class="line">  &lt;/resultMap&gt;</span><br><span class="line">  &lt;select id="selectAll1" resultSets="Student,courses" resultMap="studentMap1"&gt;</span><br><span class="line">    select * from student where SId = #{sid}</span><br><span class="line">    select * from course where SId = #{sid}</span><br><span class="line">  &lt;/select&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="元素SQL-include-select-insert"><a href="#元素SQL-include-select-insert" class="headerlink" title="元素SQL &amp; include &amp; select &amp; insert"></a>元素SQL &amp; include &amp; select &amp; insert</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!-- id : 定义 SQL 语句的唯一标识符</span><br><span class="line">    parameterType：传递SQL语句的参数类型</span><br><span class="line">    resultType:返回结果的类型</span><br><span class="line">    resultMap:引用自定义的resultMap</span><br><span class="line">    flushCache；是否在语句执行后刷新内存</span><br><span class="line">    useCache：是否使用二级缓存</span><br><span class="line">    timeout：查询超时时间</span><br><span class="line">    fetchSize：JDBC的fetch size。类似分页。如果有1000行数据，fetchSize设置200.会执行5次，最终查到1000行数据</span><br><span class="line">    statementType：语句类型，STATEMENT：直接执行sql，不预编译；PREPARED：编译sql语句支持参数华执行，防止sql注入；CALLABLE用于调用存储过程</span><br><span class="line">    resultOrdered：结果是否有序。处理多个结果集的时候，比如resultMap 的ID为studentMap1示例 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--  SQL 片段 通过include引入--&gt;</span><br><span class="line">&lt;sql id="base_sql_column"&gt;&lt;/sql&gt;</span><br><span class="line">&lt;select id="selectAll" resultType="com.read.model.Student" parameterType="int" resultMap= "studentMap" &gt;</span><br><span class="line">  select SId,</span><br><span class="line">  &lt;include refid="base_sql_column"&gt;&lt;/include&gt; </span><br><span class="line">  from student</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">  parameterType：传递SQL语句的参数类型</span><br><span class="line">  flushCache：刷新一级缓存，如果启用了二级缓存，也会刷新</span><br><span class="line">  keyProperty(对象中的属性名)：自动生成的键值对应的属性，通常与useGeneratedKeys，keyColumn（数据库中的列名，与java对象属性不一致使用）</span><br><span class="line">  一起使用。useGeneratedKeys="true" keyProperty="sid" keyColumn="SId"插入数据后，会返回主键值。</span><br><span class="line">  databaseId：区分不同的数据库配置，实现对不同数据库系统的特定 SQL 优化或适配</span><br><span class="line">  --&gt;</span><br><span class="line">&lt;insert id="insert" parameterType="com.read.model.Student" useGeneratedKeys="true" keyProperty="sid" keyColumn="SId" &gt;</span><br><span class="line">  insert into student (SId, Sname, Sage, </span><br><span class="line">    Ssex)</span><br><span class="line">  values (#{sid,jdbcType=VARCHAR}, #{sname,jdbcType=VARCHAR}, #{sage,jdbcType=TIMESTAMP}, </span><br><span class="line">    #{ssex,jdbcType=VARCHAR})</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架｜中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议之与WEB服务器</title>
      <link href="/2024/06/05/HTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E4%B8%8EWEB%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2024/06/05/HTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E4%B8%8EWEB%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p> <strong>用单台虚拟主机实现多个域名</strong> 通过基于名称的虚拟主机配置，可以在同一个IP地址上托管多个域名。</p><h3 id="通信转发程序"><a href="#通信转发程序" class="headerlink" title="通信转发程序"></a>通信转发程序</h3><p><strong>代理</strong> ：”中间人”角色，接收由客户端发送的请求并转发给服务器，同时也接受服务器返回的响应并转发给客户端。代理不会改变请求的URLI，会直接发送给前方持有资源的目标服务器。可做到针对特定URI访问的控制。<strong>缓存代理</strong>预存副本在缓存服务器上，<strong>透明代理</strong>不对报文做任何加工。反之为<strong>非透明代理</strong>。<br><img src="/../images/1717579873084.jpg"></p><p><strong>网关</strong></p><p>利用网关可以有HTTP请求转化为其他协议通信。利用网关能提高通信的安全性。可以在客户端与网关之间通信线路上加密以确保连接的安全性。</p><p><strong>隧道</strong></p><p>隧道的目的是确保客户端能与服务器进行安全的通信。隧道本身不会去解析HTTP请求。</p><h3 id="资源缓存"><a href="#资源缓存" class="headerlink" title="资源缓存"></a>资源缓存</h3><p><strong>缓存的有效期</strong> 会确认有效性。</p><p><strong>客户端缓存</strong> 临时网络文件。会确认有效性。</p><h3 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h3><p><img src="/../images/1717586328959.jpg"></p><p><strong>HTTP首部字段</strong> ：首部字段名:字段值。<strong>类型</strong>：通用首部字段，请求首部字段，响应首部字段，实体首部字段。首部指令是可选的，多个指令之间用“，”分隔。</p><p><strong>通用首部字段</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control       制缓存的行为</span><br><span class="line">Connection          跳首部、连接的管理</span><br><span class="line">Date                创建报文的日期时间</span><br><span class="line">Transfer-Encoding   指定报文主体的传输编码方式</span><br><span class="line">Upgrade             升级为其他协议</span><br><span class="line">Via                 代理服务器的相关信息</span><br><span class="line">Warning             错误通知</span><br></pre></td></tr></tbody></table></figure><p><strong>请求首部字段</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Accept              用戶代理可处理的媒体类型</span><br><span class="line">Accept-Encoding     优先的内容编码</span><br><span class="line">Accept-Language     优先的语言(自然语言)</span><br><span class="line">Host                请求资源所在服务器</span><br><span class="line">Range               实体的字节范围请求</span><br><span class="line">User-Agent          HTTP客户端程序的信息</span><br><span class="line">Proxy-Authorization 代理服务器要求客户端的认证信息</span><br></pre></td></tr></tbody></table></figure><p><strong>响应首部字段</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges       是否接受宇节范围请求</span><br><span class="line">Age                 推算资源创建经过时间</span><br><span class="line">ETag                资源的匹配信息</span><br><span class="line">Location            令客户端重定向至指定URI</span><br><span class="line">Proxy-Authenticate  代理服务器对客户端的认证信息</span><br><span class="line">Retry-After         对再次发起请求的时机要求</span><br><span class="line">Server              HTTP服务器的安装信息</span><br><span class="line">Vary                代理服务器缓存的管理信息</span><br><span class="line">WWW-Authenticate    服务器对客户端的认证信息</span><br></pre></td></tr></tbody></table></figure><p><strong>实体首部字段</strong> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Allow               资源可支持的HTTP 方法</span><br><span class="line">Content-Encoding    实体主体适用的编码方式 </span><br><span class="line">Content-Language    实体主体的自然语言 </span><br><span class="line">Content-Length      实体主体的大小 (单位:字节) </span><br><span class="line">Content-Location    替代对应资源的URI </span><br><span class="line">Content-MD5         实体主体的报文摘要</span><br><span class="line">Content-Range       实体主体的位置范围 </span><br><span class="line">Content-Type        实体主体的媒体类型 </span><br><span class="line">Expires             实体主体过期的日期时间</span><br><span class="line">Last-Modified       资源的最后修改日期时间</span><br></pre></td></tr></tbody></table></figure><p><strong>Set-Cookie</strong>: 为Cookie服务的首部字段</p><h3 id="确保Web安全的HTTPS"><a href="#确保Web安全的HTTPS" class="headerlink" title="确保Web安全的HTTPS"></a>确保Web安全的HTTPS</h3><p><strong>HTTP缺点</strong> 通信使用明文(不加密)，内容可能会被窃听；不验证通信方的身份， 因此有可能遭遇伪装；无法证明报文的完整性，所以有可能已遭篡改。</p><p><strong>HTTPS</strong> HTTP协议中没有加密机制，但可以通过和SSL或者TLS的组合使用，加密HTTP的通信内容（<strong>通信加密</strong>）。</p><p><strong>内容加密</strong> HTTP协议中没有加密机制，那么就对HTTP协议传输的内容本身加密。对报文主体加密。前提是要求客户端和服务端同时具备加密和解密机制。能有可能被篡改。</p><p><strong>不验证通信方的身份就可能遭遇伪装</strong> ：任何人都可以发起请求。<br><strong>无法证明报文完整性，可能已被篡改</strong> ：接收到的内容可能有误<br><strong>如何防止篡改</strong> ：常用的方法是MD5 和SHA-1等散列值集校验以及用来确认文件的数字签名方法。因为PGP 和MD5 本身被改写的话，用户是没有办法意识到的。用这些方法也依然无法百分百保证确认结果正确。为了有效防止这些弊端， 有必要使用<strong>HTTPS</strong>。</p><p><strong>HTTP+加密+认证+完整性保护 = HTTPS</strong> ： HTTPS是身披SSL外壳的HTTP，只是HTTP通信接口部分用SSL和TLS协议代替，通常HTTP直接和TCP通信，当使用SSL时则先和SSL通信，再有SSL和TCP通信。<br><img src="/../images/1717636990962.jpg"></p><p>SSL采用公开密钥加密，密钥是保密的。<strong>共享密钥加密</strong> 加密和解密同用一个密钥。也称为对称密钥加密。发送密钥就有被窃听的风险，但不发送，对方就不能解密。再说，密 钥若能够安全发送，那数据也应该能安全送达。<strong>公开密钥加密</strong>很好解决了共享密钥加密的困难。公开密钥加密使用非对称的密钥，一吧叫做私有密钥，一把叫做公开密钥。使用密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再用私有密钥解密。这样既不需要发送私有密钥，也不必担心密钥被攻击盗走。HTTPS采用的<strong>混合加密</strong>：使用公开密钥加密 加密 共享密钥方式中的密钥，确保安全的情况下，使用共享密钥加密方式进行通信。</p><h3 id="Session管理及Cookie应用"><a href="#Session管理及Cookie应用" class="headerlink" title="Session管理及Cookie应用"></a>Session管理及Cookie应用</h3><p>基于表单认证是通过服务器端的Web应用，将客户端发送来的用户Id和密码与之前登陆过的信息做匹配来进行认证。HTTP是无状态协议，于是会使用Coolie来管理Session，来弥补HTTP协议中不存在的状态管理功能。<br><img src="/../images/1717641701756.jpg"><br>1、客户端发送用户ID和密码等登录信息到服务器<br>2、服务器发放用以识别用户的SessionId，返回是会在首部字段Set-Cookie写入SessionId<br>3、客户端收到服务器端发来的Session ID后，将其作为Cookie保存在本地。下次发送请求时，浏览器或自动发送Cookie。</p><p><strong>加盐</strong>：一种安全的保存密码方法，先利用给密码加盐的方式增加额外信息，在使用散列函数计算出散列值后保存。</p><h3 id="HTTP瓶颈"><a href="#HTTP瓶颈" class="headerlink" title="HTTP瓶颈"></a>HTTP瓶颈</h3><p>使用HTTP协议探知服务器上是否有内容更新，就必须频繁的从客户端到服务端进行确认。（1、不管是否有更新都要吧数据全部响应一次。2、每次互相发送相同的首部。3、有时不压缩数据直接发送）。</p><p><strong>Ajax</strong> 有效利用JavaScript和DOM的操作，以达到局部Web页面替换加载的异步通信手段。但是并没有解决HTTP协议本身的问题。</p><h3 id="全双工通信的WebSocket"><a href="#全双工通信的WebSocket" class="headerlink" title="全双工通信的WebSocket"></a>全双工通信的WebSocket</h3><p>WebSocket，即Web浏览器与Web服务器之间全双工通信标准。</p><p>一旦建立WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可以互次昂发送JSON，XML或图片等任意格式的数据。</p><p><strong>WebSocket协议</strong> 主要特点：<br>推送功能：支持由服务器向客户端推送数据的推送功能。<br>减少通信量：只要建立起WebSocket 连接，就希望一直保持连接状态。位了实现WebScoket通信，在HTTP连接建立之后，需要完成一次握手的步骤。成功握手确立WebScoket连接之后，通信时不再使用HTTP的数据帧，而采用WebSocket独立的数据帧。<br><img src="/../images/1717665892946.jpg"></p><h3 id="Web攻击技术"><a href="#Web攻击技术" class="headerlink" title="Web攻击技术"></a>Web攻击技术</h3><p>简单的HTTP协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击的对象。应用HTTP协议的服务器和客户端，以及运行在服务器上的web应用等资源才是攻击目标。</p><p><strong>在客户端即可篡改请求</strong></p><p><strong>针对Web应用的攻击模式</strong><br>主动攻击：<br><img src="/../images/1717667317285.jpg"><br>被动攻击：具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。<br><img src="/../images/1717667403282.jpg"></p><p><strong>利用用户的身份攻击企业内部的网络</strong><br>利用被动攻击，可发起对原本从互联网上无法直接访问的企业内网等网络的攻击。</p><p><strong>跨站脚本攻击</strong> 跨站脚本政击(Cross-SiteScripting，XSS)是指通过存在的安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。XSS是攻击者利用预先设置的陷阱触发的被动攻击。</p><p><strong>SQL注入攻击</strong></p><p><strong>OS命令注入攻击</strong></p><p><strong>HTTP首部注入攻击</strong></p><p><strong>HTTP响应截断攻击</strong></p><p><strong>邮件首部注入攻击</strong></p><p><strong>远程文件包含漏洞</strong></p><p><strong>开放重定向</strong> 是一种对指定的任意URL作重定向<br>跳转的功能。而于此功能相关联的安全漏洞是指，假如指定的重定向URL到某个具有恶意的Web网站，那么用户就会被诱导至那个Web网站。</p><p><strong>会话劫持</strong> 会话劫持(Session Hiack )是指攻击者通过某种手段拿到了用户的<br>会话1D，并非法使用此会话1D 份装成用户，达到攻击的目的。</p><p><strong>会话固定攻击</strong>对以窃取目标会话ID为主动攻击手段的会话劫持而言，会话固定攻击(Sesion Fixation )攻击会强制用户使用攻击者指定的会话ID，属于被动攻击。</p><p><strong>跨站点请求伪造</strong> 可能造成的问题：<br>• 利用己通过认证的用户权限更新设定信息等<br>• 利用己通过认证的用户权限购买商品<br>• 利用己通过认证的用户权限在留言板上发表言论</p><p><strong>点击劫持</strong><br>点击劫持是指利用透明的按钮或链接做成陷阱，覆盖在web页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装。</p><p><strong>DOS攻击</strong> DOS攻击是一种让运行中的服务呈停止状态的攻击。</p><p><strong>后门程序</strong> 后门程序(Backdoor )是指开发设置的隐藏入口，可不按正常步骤使用受限功能。可通过监视进程和通信的状态发现被植人的后门程序。但设定在 web 应用中的后门程序，由于和正常使用时区别不大，通常很难发现。</p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议之详情</title>
      <link href="/2024/06/04/HTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E8%AF%A6%E6%83%85/"/>
      <url>/2024/06/04/HTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E8%AF%A6%E6%83%85/</url>
      
        <content type="html"><![CDATA[<p>HTTP报文大致分为报文首部和报文主体两块。[ <strong>报文首部</strong>]服务器端或者客户端需要处理的请求或响应的内容及属性。[ <strong>CR+LF</strong>]空行，[ <strong>报文主体</strong>]应被发送的数据。<br><img src="/../images/%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.jpg"></p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="提升传输效率"><a href="#提升传输效率" class="headerlink" title="提升传输效率"></a>提升传输效率</h3><p><strong>压缩传输的内容编码</strong>：如邮件添加附件（压缩附件）。常用的内容编码：gzip，compress(UNIX系统标准压缩)，deflate(zlib),identity(不进行编码)。<br><strong>分割发送的分块传输编码</strong>：chunked(Content-Length:null Transfer-Encoding:chunked) 把实体主体分块的功能。HTTP/1.1中存在一种称为传输编码的机制。HTTP/2 中已经不支持 chunked 这一格式了，因为其本身提供了更加高级的流机制来实现类似功能.</p><h3 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h3><p>HTTP协议中也采纳了多部分对象集合，发送一份报文主体内可以包含多种类型的实体。通常是在图片或者文本文件等上传时使用。<strong>multipart/form-date</strong>在web表单文件上传时使用。<strong>nultipart/byteranges</strong>状态码206，响应报文包含多个范围的内容时使用。</p><h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>解决网络中断，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处回复下载。实现该功能需要指定下载的范围实体(<strong>范围请求</strong>)。使用范围请求时，会用到首部字段Range来指定资源的byte范围。<br><img src="/../images/%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82.jpg"></p><h3 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h3><p>内容协商机制是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。聂荣协商会以响应资源的语言，字符集，编码方式等作为判断基准。<strong>服务器驱动协商</strong>，<strong>客户端驱动协商</strong>，<strong>透明协商</strong></p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1XX -&gt; 信息性状态码 -&gt; 接收的请求正在处理</span><br><span class="line">2XX -&gt; 成功状态码 -&gt; 请求正常处理完毕</span><br><span class="line">    200 OK</span><br><span class="line">    204 No Content</span><br><span class="line">    206 Partial Content 范围请求你</span><br><span class="line">3XX -&gt; 重定向状态码 -&gt; 需要进行附加操作以完成请求</span><br><span class="line">    301 Moved Permanently 永久性重定向</span><br><span class="line">    302 Found 临时性重定向</span><br><span class="line">    303 See Other 该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源</span><br><span class="line">    304 </span><br><span class="line">    307</span><br><span class="line">4XX -&gt; 客户端错误状态码 -&gt; 服务器无法处理请求</span><br><span class="line">    400 Bad Request 表示请求报文存在语法错误</span><br><span class="line">    401 Unauthorized 发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息</span><br><span class="line">    403 Forbidden 对请求资源的访问被服务器拒绝了</span><br><span class="line">    404 Not Found 服务器没有请求的资源</span><br><span class="line">5XX -&gt; 服务器错误状态码 -&gt; 服务器处理请求出错</span><br><span class="line">    500 服务器端在执行请求发生了错误</span><br><span class="line">    503 服务器暂时处于超负载或者正在停机维护 </span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议之基础</title>
      <link href="/2024/06/03/HTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/06/03/HTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>HTTP 是一种用作获取诸如 HTML 文档这类资源的协议。它是 Web 上进行任何数据交换的基础，同时，也是一种客户端—服务器（client-server）协议，也就是说，请求是由接受方——通常是浏览器——发起的。一个完整网页文档是由获取到的不同文档组件——像是文本、布局描述、图片、视频、脚本等——重新构建出来的。<br><img src="/../images/HTTP%E6%A6%82%E8%BF%B0.jpg" alt="HTTP协议之基础"></p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="1、网络基础"><a href="#1、网络基础" class="headerlink" title="1、网络基础"></a>1、网络基础</h3><p>&nbsp;&nbsp;TCP/IP协议族是各类互联网相关的各类协议族的总称。TCP/IP协议族最重要的就是分层：应用层，传输层，网络层，数据链路层。</p><p><strong>应用层</strong>：应用层决定了向用户提供应用服务时通信的活动。TCP/IP协议族内预存了各类通用的应用服务。比如HTTP协议,FTP(文件传输协议)，DNS(域名服务)。</p><p><strong>传输层</strong>：传输层对上层应用，提供处于网络连接中的两台计算机的网络传输。在传输层有两个性质不同的协议：TCP(传输控制协议)，UDP(用户数据报协议)。</p><p><strong>网络层</strong>：网络层是用来处理网络上流动的数据包。数据包是网络传输的最小数据单位，该层规定了通过怎样的路径，到达对应的计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或者网络设备进行传输时，网络层所起的作用就是在众多的选项中选择一条传输路线。</p><p><strong>链路层（网络接口层）</strong>：用来处理网络的硬件部分。包括控制操作系统，硬件的设备驱动，NIC(网络适配器：网卡)及光线等物理可见部分，硬件的范畴均在链路层的作用范围之内。</p><p><img src="/../images/%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E6%B5%81.jpg" alt="TCP/IP通信传输流"></p><p><strong>负责传输的IP协议</strong>：IP地址指明了节点被分配的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对，IP地址可更换，但MAC地址基本上不会改变。IP间的通信依赖MAC地址，在网络上，通常是经过多台计算机和网络设备中转才能连接到对方，在中转过程中会利用下一站的MAC地址来搜索下一个中转目标。会采用<strong>ARP协议</strong>，ARP协议是一种用来解析地址的协议。根据通信方的IP地址就可以查出对应的MAC地址。</p><p><strong>可靠的TCP协议</strong>：TCP位于传输层，提供可靠的字节流服务。字节流服务是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠的传给对方。为了准确无误将数据送达目标，TCP协议采用了三次握手策略。<br><img src="/../images/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%AE%80.jpg" alt="三次握手（简）"></p><p><strong>域名解析DNS服务</strong>：和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。<br><img src="/../images/%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt="与HTTP关系图"></p><h3 id="2、简单的HTTP协议"><a href="#2、简单的HTTP协议" class="headerlink" title="2、简单的HTTP协议"></a>2、简单的HTTP协议</h3><p>HTTP协议和TCP/IP协议族内的其他众多的协议相同，用于客户端和服务器之间的通信。HTTP是一种不保存协议，即<strong>无状态协议</strong>。HTTP协议自身不对请求和响应之间的通信状态进行保存。HTTP/1.1虽然也是无状态协议，但是为了实现期望的保存状态功能，引入了Cookie技术。</p><p>HTTP/1.1方法 –&gt;<br>&nbsp;&nbsp;&nbsp; <strong>GET</strong>:获取资源<br>&nbsp;&nbsp;&nbsp; <strong>POST</strong> 传输实体主体<br>&nbsp;&nbsp;&nbsp; <strong>PUT</strong>：传输文件<br>&nbsp;&nbsp;&nbsp; <strong>HEAD</strong>：获得报文首部（不返回报文主体部分）<br>&nbsp;&nbsp;&nbsp; <strong>DELETE</strong>：删除文件<br>&nbsp;&nbsp;&nbsp; <strong>OPTIONS</strong>：询问支持的方法（如支持GET和HEAD方法）<img src="/../images/OPTIONS%E6%96%B9%E6%B3%95.jpg"><br>&nbsp;&nbsp;&nbsp; <strong>TRACE</strong>：追踪路径（不常用，容易引发SXST攻击）<br>&nbsp;&nbsp;&nbsp; <strong>CONNECT</strong>：要求用隧道协议连接代理，要求在代理服务器通信时建立隧道，实现隧道协议惊醒TCP通信。主要使用SSL(安全套阶层)和TLS(传输层安全)协议把通信内容加密后经过网络隧道传输。格式：CONNECT 代理服务器名:端口号 HTTP版本 。场景：HTTPS代理，防火墙和安全网关，VPN服务等</p><p>在HTTP/1.1中，所有的连接默认都是持久连接（长连接），在HTTP/1.0还没有标准化。持久化连接是的多数请求翼<strong>管线化</strong>(pipelining)方式发送层成为可能。从前发送请求后需要等待并收到响应，才能发送下一个请求。管线化技术出现后，不能等待响应可以直接发送下次请求。</p><p><strong>Cookie状态管理</strong>：Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部信息，通知客户端保存Cookie。当客户端再次发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。<br><img src="/../images/Cookie%E4%BA%A4%E4%BA%92.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql记录存储结构</title>
      <link href="/2024/06/01/Mysql%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
      <url>/2024/06/01/Mysql%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>服务器程序在处理来自客户端的查询请求时，大致需要分为3部分：连接管理，解析与优化，存储引擎。<br><img src="/../images/1717725217845.jpg"></p><h2 id="InnoDB记录存储结构"><a href="#InnoDB记录存储结构" class="headerlink" title="InnoDB记录存储结构"></a>InnoDB记录存储结构</h2><p><strong>InnoDB行</strong> : InnoDB存储引擎有4种不同类型的行格式。分别是COMPACT，REDUNDANT，DYNAMIC，COMPRESSED。</p><h3 id="InnoDB-COMPACT行格式"><a href="#InnoDB-COMPACT行格式" class="headerlink" title="InnoDB-COMPACT行格式"></a>InnoDB-COMPACT行格式</h3><p><img src="/../images/COMPACT%E8%A1%8C%E6%A0%BC%E5%BC%8F.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table record_format_demo(</span><br><span class="line">    c1 varchar(10),</span><br><span class="line">    c2 varchar(10) not null,</span><br><span class="line">    c3 char(10),</span><br><span class="line">    c4 varchar(10)</span><br><span class="line">) charset=ascii row_format = compact;</span><br><span class="line"></span><br><span class="line">insert into record_format_demo (c1,c2,c3,c4)values('aaaa','bbb','cc','d'),('eeee','fff',NULL,NULL);</span><br></pre></td></tr></tbody></table></figure><p><strong>1、变长字段长度列表</strong><br>分为2部分：1、真正的数据内容；2、该数据占用的字节数。变长字段字节是按照逆序排列。</p><blockquote><p>★ 并不是所有记录都有这个变长字段长度列表部分，如果表中所有的列都不是变长数据类型或者所有的值都是NULL的话，就不需要变长字段长度列表。<br>★ 引入W字节来表示一个字符，utf8mb4字符集种W=4，utf8字符集中W=3,gbk字符集中W=2；引入M表示字符；引入L表示实际存储的字节数；对于VARCHAR(M)来说，最多占用字节数就是M * W。<br>★ <strong>长度前缀</strong>使用1个字节表示，还是用2个字节表示。规则如下：</p><blockquote><p>如果M * W &lt;= 255,那么使用一个字节的长度前缀。<br>如果M * W &gt;= 255,则又分2种情况：1、如果L &lt;= 127 则用1个字节的长度前缀；2、如果 L &gt; 127 ,则用2个字节的长度前缀。</p></blockquote></blockquote><p><strong>2、NULL值列表</strong></p><blockquote><p>★ 只通知允许为存储NULL的列。<br>★ 如果表中没有允许存储NULL的列，则NULL值列表就不存在了。<br>★ NULL值标志位用二进制记录，按照列的顺序逆序排列。值为1时，代表为NULL，为0时，代表不为NULL。</p></blockquote><p><strong>3、记录头信息</strong></p><blockquote><p>★由固定的5个字节组成，也就是40位二进制组成。<br><img src="/../images/compact-%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF.png"></p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">预留位1                  1位             没有使用    </span><br><span class="line">预留位2                  1位             没有使用    </span><br><span class="line">deleted_flag            1位             标记是否被删除</span><br><span class="line">min_rec_flag            1位             最小记录标记，通常用来标记页面中的最小记录(索引优化，快速定位最小记录)</span><br><span class="line">n_owned                 4位             用于表示当前记录拥有记录槽(solt)的数量，这些槽可以用来存储实际的记录数据</span><br><span class="line">                                            也可以用来管理页中自由空间：管理记录链表，优化页面存储</span><br><span class="line">heap_no                 13位            标识记录在页中的位置，它是记录在数据页中的唯一标识符，可以帮助快速定</span><br><span class="line">                                            位特定记录； 来管理和组织页中的记录。它在记录的插入、更新和删除操作中起到关键作用；  有助于页内记录的排序和管理。</span><br><span class="line">record_type             3位             区分记录类型： 0 (ORDINARY_RECORD)：普通记录，表示实际的用户数据记录</span><br><span class="line">                                                    1 (NODE_POINTER)：节点指针，表示B+树中指向子节点的指针记录。</span><br><span class="line">                                                    2 (INFIMUM)：页的最小记录（infimum record），用于页的边界管理。</span><br><span class="line">                                                    3 (SUPREMUM)：页的最大记录（supremum record），用于页的边界管理。</span><br><span class="line">next_record             16位            用于指向下一条记录(表示下一条记录的相对位置)；用途：顺序扫描；范围查询；</span><br><span class="line">                                            插入和删除操作</span><br></pre></td></tr></tbody></table></figure><p><img src="/../images/COMPACT%E8%AF%A6%E7%BB%86.png"></p><p><strong>4、记录的真实数据</strong></p><p>mysql会为每个记录默认添加一些列（隐藏列）DB_ROW_ID,DB_TRX_ID,DB_ROLL_PTR。<br>InnoDB主键生成策略：  1、优先使用自定义主键；2、其次不允许为空的UNQUE（唯一）键作为主键；3、最后默认添加row_id的隐藏列作为主键</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">列名            是否必需        占用字节            描述</span><br><span class="line">row_id          否              6字节           行ID，唯一标识</span><br><span class="line">trx_id          是              6字节           事务ID</span><br><span class="line">roll_pointer    是              7字节           回滚指针</span><br></pre></td></tr></tbody></table></figure><p>CHAR(M)类型是定长，不属于变长字段，不会记录到变长字段长度列表中。</p><h3 id="InnoDB-REDUNDANT行格式"><a href="#InnoDB-REDUNDANT行格式" class="headerlink" title="InnoDB-REDUNDANT行格式"></a>InnoDB-REDUNDANT行格式</h3><p>REDUNDANT行格式是mysql5.0之前就在使用的一种行格式。<br><img src="/../images/REDUNDANT%E8%A1%8C%E6%A0%BC%E5%BC%8F.png"></p><p><strong>1、字段长度偏移列表</strong></p><p>REDUDANT行格式会把记录中<strong>所有的</strong>列的长度信息都按照逆序存储到字段长度偏移列表中。而且采用两个相邻偏移量的差值来计算各个列的长度。<br>也是逆序排列</p><p>与COMPACT行格式相比，REDUNDANT行格式多了n_field和1byte_offs_flag这两个属性；没有record_type这个属性。</p><p>REDUNDANT行格式没有NULL值列表：在字段长度偏移列表中对各列对应的偏移量做了特殊处理—将对应的偏移量值的第一位作为是否为NULL的依据，也称为NULL值比特位。如果该值为1，该列就为NULL。</p><p>如果存储的NULL值字段是定长字段，则NULL值也将占用记录的真实数据部分；如果存储的NULL值字段是变长数据类型，则不在记录的真实数据部分占用任何存储空间。</p><h3 id="溢出列"><a href="#溢出列" class="headerlink" title="溢出列"></a>溢出列</h3><p>InnoDB中磁盘和内存交互的基本单位是页。也就是说InnoDB是以页为基本单位来管理存储空间的。一个页的大小一般是16kb。在COMPACT和REDUNDANT行格式中，对于占用存储空间非常多的列。在记录真实数据处只会存储该列的一部分数据，而把<strong>剩余的数据分散存储到几个其他的页</strong>中。然后在记录真实数据处用20字节存储指向这些页的<strong>地址</strong>（还有存粗在其他页数据的<strong>字节数</strong>）。</p><p><img src="/../images/%E6%BA%A2%E5%87%BA%E9%A1%B5.png"></p><p><strong>一个列存储多少字节之后会变成溢出列呢？</strong> 一个页默认16kb也就是16384字节，mysql中规定一个页中至少存放2行数据。<br>1、除了存放记录外，还需要存储一些额外的信息。共132字节空间。<br>2、每个记录需要额外信息是27个字节：2字节存储真实数据长度；1字节存储NULL值；5个字节存储头信息；6个字节的Row_id列；6字节的trx_id列；7字节的roll_pointer列。假设一个列的真实数据占用的字节数为n：如果该列不发生溢出现象，就需要满足不等式：132+2*(27+n)&lt;16384。</p><p><strong>mysql版本5.7之后，默认使用DYNAMIC行格式</strong> ，DYNAMIC行格式和COMPRESSED行格式与COMPACT类似：但是处理<strong>溢出列不同</strong>：DYNAMIC行格式不会存储真实数据，而是把所有的真实数据都存储到溢出页中。只记录真实数据处存储20字节大小的指向溢出页的地址。COMPRESSED行格式会采用压缩算法对页面进行压缩。以节省空间。</p><p><strong>REDUNDANT是一种比较原始的韩格式，非紧凑型。而DYNAMIC，COMPACT，COMPRESSED 是较新的行格式，紧凑型(占用存储空间更少)</strong></p><h2 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h2><p><img src="/../images/%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84.png"></p><h3 id="记录存储"><a href="#记录存储" class="headerlink" title="记录存储"></a>记录存储</h3><p>第二条记录被标记为删除，将被删除的记录加入到垃圾链表中是2个阶段。多条被删除的记录next_record会形成垃圾链表。<br>Infimum记录和Supremum记录没有主键，Infimum记录是页面中最小的记录，Supremum记录是页面中最大的记录。<br>堆中的Heap_no值被分配之后就不会再改变，即使删除了某条记录也不会变。<br>next_record属性，箭头总是指向下一条记录的头记录和真实数据中间位置（<strong>紫色箭头</strong>），因为记录头逆序排列，向左读区是记录头信息，向右读区是真实数据。变长字段长度列表，null列表都是逆序排列，记录中靠前的字段和对应的字段信息在内存中更近，提高缓存命中率。<br>被删除的记录不会再被上一条记录指向（<strong>红色箭头</strong>）</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E9%A1%B5%E2%80%94%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF.png"></p><h3 id="页目录"><a href="#页目录" class="headerlink" title="页目录"></a>页目录</h3><p>将所有的记录(除去已经移除到垃圾链表的记录)划分为组，将每组中最后一条记录在页面只能够的地址偏移量（该记录真实数据与页面第0个字节之间的距离）单独提取出来（带头大哥属性n_owned为该组中记录数量），按照顺序存储到靠近尾部的地方。这个就是Page Directory（页目录）。页中这些地址偏移量称为槽（Slot），每个槽占用2个字节，页目录就是由多个槽组成的。</p><p>每个分组中记录条数<strong>规定</strong>：Infimum记录所在的分组只能有一条记录。Supremum记录所在的分组拥有的记录条数只能在1～8条之间。其他的分组中记录的条数范围只能在4～8条之间。</p><blockquote><p>1、初始情况，一个页只有Infimum和Supremum记录，也就是2个分组。<br>2、每插入一条记录。都会从页目录中找到对应记录的主键值比待插入记录主键值大并且差值最小的槽。然后把对应槽的n_owned加1.直到改组中记录数等于8.<br>3、当一个组中的数据等于8之后，再插入记录，会将组中的记录拆分成2个组。拆分过程中新增一个槽。</p></blockquote><h3 id="页面头部"><a href="#页面头部" class="headerlink" title="页面头部"></a>页面头部</h3><p>Page Header 占用固定56个字节，专门存储各种状态信息。比如数据也中存了多少记录，Free Space字页面中的地址偏移量，也目录中存储了多少槽等。</p><blockquote><p>PAGE_N_DIR_SLOTS       2字节       在页目录中的槽数量<br>PAGE_HEAP_TOP           2字节       还未使用的空间最小地址，从改地址之后就是Free Space<br>PAGE_N_HEAP             2字节       第一位表示是否为紧凑型，后15位表示本页中的堆中记录的数量<br>PAGE_FREE               2字节       各个已删除的记录通过next_record组成一个单向链表，这个单向链表中记录的所占用的存储空间可<br>                                        以被重新利用。PAGE_FREEbao表示该链表头节点对应记录在页面中的偏移量。<br>PAGE_GARBAGE            2字节       已删除记录占用的字节数<br>PAGE_LAST_INSERT        2字节       最后插入记录的位置<br>PAGE_DIRECTION          2字节       记录插入的方向<br>PAGE_N_DIRECTION        2字节       一个方向连续插入的记录数量<br>PAGE_N_RECS             2字节       该也中用户记录的数量<br>PAGE_MAX_TRX_ID         2字节       修改当前页面的最大事物ID，仅存在二级索引页面中定义<br>PAGE_LEVEL              2字节       当前页在B+数中所处的层级<br>PAGE_INDEX_ID           8字节       索引ID，表示当前页属于那个索引<br>PAGE_BTR_SRE_LEAF       10字节      B+数也字节点段的头部信息，仅在B+数的根页面中定义<br>PAGE_BTR_SEG_TOP        2字节       B+数非叶字节点段的头部信息，仅存在B+数的根页面中定义</p></blockquote><h3 id="文件头部"><a href="#文件头部" class="headerlink" title="文件头部"></a>文件头部</h3><p><strong>File Header</strong>部分占用固定38字节，描述一些通用于各种页的信息，不如页扽编号，上一个页和下一个页面等等。</p><p><strong>各种页面的类型</strong>：</p><blockquote><p>FILE_PAGE_TYPE_ALLOCATED           最新分配，还未使用<br>FIL_PAGE_UNDO_LOG                   undo日志页<br>FIL_PAGE_INODE                      存储段的信息<br>FIL_PAGE_IBUG_FREE_LIST             Change Buffer空闲列表<br>FIL_PAGE_IBUF_BITMAP                Change Buffer的一些属性<br>FIL_PAGE_TYPE_SYS                   存储一些系统数据<br>FIL_PAGE_TYPE_TRX_SYS               事务系统数据<br>FIL_PAGE_TYPE_FSP_HDR               表空间头部信息<br>FIL_PAGE_TYPE_FSP_HDR               存储区的一些属性<br>FIL_PAGE_TYPE_BLOB                  溢出页<br>FIL_PAGE_INDEX                      索引页（数据页）</p></blockquote><p><strong>存储记录的数据页面是可以组成一个双向链表</strong></p><h3 id="文件尾部"><a href="#文件尾部" class="headerlink" title="文件尾部"></a>文件尾部</h3><p>File Trailer由8个字节组成。用于校验页是否完整。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
