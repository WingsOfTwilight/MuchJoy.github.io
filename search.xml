<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql—B+树</title>
      <link href="/2024/06/29/Mysql%E2%80%94B-%E6%A0%91/"/>
      <url>/2024/06/29/Mysql%E2%80%94B-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><strong>B+树的结构</strong></p><blockquote><p>根节点：B+树的等层节点，包含键值和指向子节点的指针。<br>内部节点：位于根节点和叶子结点之间的节点，包含键值和指向字节点的指针。<br>叶子节点：B+树最底层的节点，包含所有的数据记录和下一个叶子节点的指针。</p></blockquote><p><strong>B+树的特点</strong></p><blockquote><p>1、所有的数据都存储在叶子节点上，非叶子节点只存储键值和指向字节点的指针。<br>2、顺序访问指针，每个叶子节点都包含一个指向下一个叶子节点的指针。使得B+树可以高效的进行顺序扫描。<br>3、平衡树，即从根节点到任何叶子节点的路径长度相同，从而保证了查询，插入，删除操作的时间复杂度都是O(log n).<br>4、高扇出性，由于每个节点都包含多个叶子节点，B+树的高低较低，使得磁盘I/O操作更高效。</p></blockquote><p><strong>B+树在mysql中的应用</strong></p><blockquote><p>聚簇索引：InnoDB表的主键索引实际上是一个B+树，表中的数据行按照主键的顺序存储在叶子节点中。<br>二级索引：非主键索引也是B+树结构，叶子节点存储索引列和主键值，用于快速定位数据行。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis初始化</title>
      <link href="/2024/06/17/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2024/06/17/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><strong>Mybatis工作流程</strong></p><p><img src="/../images/Mybatis%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p><h2 id="mybatis初始化方式"><a href="#mybatis初始化方式" class="headerlink" title="mybatis初始化方式"></a>mybatis初始化方式</h2><p><strong>1、基于XML配置文件</strong>：基于XML配置文件的方式是将MyBatis的所有配置信息放在XML文件中，MyBatis通过加载并XML配置文件，将配置文信息组装成内部的Configuration对象。</p><p><strong>2、基于Java API</strong>：这种方式不使用XML配置文件，需要MyBatis使用者在Java代码中，手动创建Configuration对象，然后将配置参数set 进入Configuration对象中。</p><h3 id="基于XML方式"><a href="#基于XML方式" class="headerlink" title="基于XML方式"></a>基于XML方式</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 加载 MyBatis 配置文件</span><br><span class="line">String resource = "mybatis-config.xml";</span><br><span class="line">Reader reader = Resources.getResourceAsReader(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">// 获取 SqlSession</span><br><span class="line">try (SqlSession session = sqlSessionFactory.openSession()) {</span><br><span class="line">    // 获取 Mapper</span><br><span class="line">    StudentMapper mapper = session.getMapper(StudentMapper.class);</span><br><span class="line">    // 执行查询</span><br><span class="line">    Student user = mapper.selectAll().get(0);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码一共经历了三个阶段：mybatis初始化，获取SqlSession，执行SQL语句。</p><p>上述代码功能根据加载mybatis-config.xml文件，创建SqlSessionFactory对象，然后获取SqlSession，执行sql语句。而mybatis初始化就是SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);</p><p>mybatis初始化基本过程如下图：<br><img src="/../images/mybatis%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B.png"></p><p>如上图，mybatis初始化经过一下几个步骤：<br>1、调用SqlSessionFactoryBuilder对象的build(reader)方法。<br>2、SqlSessionFactoryBuilder根据传入的字符流，创建XMLConfigBuilder对象。<br>3、XMLConfigBuilder对象调用Parse()方法，创建Configuration对象。<br>4、SqlSessionFactoryBuilder根据Configuration对象创建DefaultSqlSessionFactory对象。<br>5、SqlSessionFactoryBuilder返回SqlSessionFactory供客户端使用。</p><p>相关代码如下:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {</span><br><span class="line">  try {</span><br><span class="line">    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">    return build(parser.parse());</span><br><span class="line">  } catch (Exception e) {</span><br><span class="line">    throw ExceptionFactory.wrapException("Error building SqlSession.", e);</span><br><span class="line">  } finally {</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    try {</span><br><span class="line">      inputStream.close();</span><br><span class="line">    } catch (IOException e) {</span><br><span class="line">      // Intentionally ignore. Prefer previous error.</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public SqlSessionFactory build(Configuration config) {</span><br><span class="line">  return new DefaultSqlSessionFactory(config);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>创建Configuration的过程</strong></p><blockquote><p>parse()方法是如何处理XML文件，并生成Configuration对象的呢？</p></blockquote><p><strong>1、XMLConfigBuilder对象会将传入的XML信息转成Document对象</strong><br>而创建XPathParser对象，会创建XMLMapperEntityResolver对象(XML配置定义文件DTO)，然后将XMLMapperEntityResolver对象和Document封装到XPathParser对象中。<br>XPathParser对象会根据XPath表达是获取基本的Document节点Node信息。</p><p><strong>2、之后XMLConfigBuilder对象会调用parse()</strong><br>会从XPathParser对象中取出根节点configuration信息，然后继续获取properties，settings，typeAliases，plugins，objectFactory,objectFactory,objectWrapperFactory,reflectorFactory,environments,databaseIdProvider,typeHandlers,mappers节点信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public Configuration parse() {</span><br><span class="line">  if (parsed) {</span><br><span class="line">    throw new BuilderException("Each XMLConfigBuilder can only be used once.");</span><br><span class="line">  }</span><br><span class="line">  parsed = true;</span><br><span class="line">  parseConfiguration(parser.evalNode("/configuration"));</span><br><span class="line">  return configuration;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">private void parseConfiguration(XNode root) {</span><br><span class="line">  try {</span><br><span class="line">    // issue #117 read properties first</span><br><span class="line">    propertiesElement(root.evalNode("properties"));</span><br><span class="line">    Properties settings = settingsAsProperties(root.evalNode("settings"));</span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    loadCustomLogImpl(settings);</span><br><span class="line">    typeAliasesElement(root.evalNode("typeAliases"));</span><br><span class="line">    pluginElement(root.evalNode("plugins"));</span><br><span class="line">    objectFactoryElement(root.evalNode("objectFactory"));</span><br><span class="line">    objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));</span><br><span class="line">    reflectorFactoryElement(root.evalNode("reflectorFactory"));</span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    // read it after objectFactory and objectWrapperFactory issue #631</span><br><span class="line">    environmentsElement(root.evalNode("environments"));</span><br><span class="line">    databaseIdProviderElement(root.evalNode("databaseIdProvider"));</span><br><span class="line">    typeHandlerElement(root.evalNode("typeHandlers"));</span><br><span class="line">    mapperElement(root.evalNode("mappers"));</span><br><span class="line">  } catch (Exception e) {</span><br><span class="line">    throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>3、然后将这些信息设置到Configuration对象中</strong><br><strong>4、返回Configuration对象</strong></p><h3 id="基于Java-API"><a href="#基于Java-API" class="headerlink" title="基于Java API"></a>基于Java API</h3><p><strong>1、创建配置类</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MyBatisConfig {</span><br><span class="line">    public SqlSessionFactory getSqlSessionFactory() {</span><br><span class="line">        // 创建数据源</span><br><span class="line">        PooledDataSource dataSource = new PooledDataSource();</span><br><span class="line">        dataSource.setDriver("com.mysql.cj.jdbc.Driver");</span><br><span class="line">        dataSource.setUrl("jdbc:mysql://localhost:3306/mydatabase");</span><br><span class="line">        dataSource.setUsername("root");</span><br><span class="line">        dataSource.setPassword("password");</span><br><span class="line"></span><br><span class="line">        // 创建MyBatis配置对象</span><br><span class="line">        Configuration configuration = new Configuration();</span><br><span class="line">        configuration.setEnvironment(</span><br><span class="line">            new org.apache.ibatis.mapping.Environment(</span><br><span class="line">                "development",</span><br><span class="line">                new org.apache.ibatis.transaction.jdbc.JdbcTransactionFactory(),</span><br><span class="line">                dataSource</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 添加Mapper</span><br><span class="line">        configuration.addMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        // 构建SqlSessionFactory</span><br><span class="line">        return new SqlSessionFactoryBuilder().build(configuration);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>2、使用配置类初始化mybatis</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyBatisExample {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        // 获取SqlSessionFactory</span><br><span class="line">        MyBatisConfig config = new MyBatisConfig();</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = config.getSqlSessionFactory();</span><br><span class="line">        </span><br><span class="line">        // 使用SqlSession</span><br><span class="line">        try (SqlSession session = sqlSessionFactory.openSession()) {</span><br><span class="line">            UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">            User user = mapper.selectUser(1);</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>1、创建数据源：通过PooledDataSource创建数据源并配置数据库连接信息。<br>2、创建MyBatis配置对象：创建Configuration对象并配置环境（Environment）、事务管理器（JdbcTransactionFactory）和数据源。<br>3、添加Mapper：通过configuration.addMapper(UserMapper.class)方法将Mapper接口添加到配置中。<br>4、构建SqlSessionFactory：通过SqlSessionFactoryBuilder构建SqlSessionFactory。<br>5、使用SqlSession：通过sqlSessionFactory.openSession()获取SqlSession，并使用Mapper执行数据库操作。</p>]]></content>
      
      
      <categories>
          
          <category> 框架｜中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis配置</title>
      <link href="/2024/06/17/Mybatis%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/06/17/Mybatis%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>Mybatis架构图</strong></p><p><img src="/../images/Mybatis%E6%9E%B6%E6%9E%84.png"></p><p>接口层：主要就是和数据库交互。<br>数据处理层：可以说是MyBatis 的核心，负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等，它主要的目的是根据调用的请求完成一次数据库操作。<br>mapper.xml配置sql和映射关系就是基于xml方式（基础支撑层）</p><h2 id="mybatis配置解析方法"><a href="#mybatis配置解析方法" class="headerlink" title="mybatis配置解析方法"></a>mybatis配置解析方法</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public Configuration parse() {</span><br><span class="line">  if (parsed) {</span><br><span class="line">    throw new BuilderException("Each XMLConfigBuilder can only be used once.");</span><br><span class="line">  }</span><br><span class="line">  parsed = true;</span><br><span class="line">   //configuration为根节点</span><br><span class="line">  parseConfiguration(parser.evalNode("/configuration"));</span><br><span class="line">  return configuration;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  private void parseConfiguration(XNode root) {</span><br><span class="line">  try {</span><br><span class="line">    // issue #117 read properties first</span><br><span class="line">    propertiesElement(root.evalNode("properties"));</span><br><span class="line">    Properties settings = settingsAsProperties(root.evalNode("settings"));</span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    loadCustomLogImpl(settings);</span><br><span class="line">    typeAliasesElement(root.evalNode("typeAliases"));</span><br><span class="line">    pluginElement(root.evalNode("plugins"));</span><br><span class="line">    objectFactoryElement(root.evalNode("objectFactory"));</span><br><span class="line">    objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));</span><br><span class="line">    reflectorFactoryElement(root.evalNode("reflectorFactory"));</span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    // read it after objectFactory and objectWrapperFactory issue #631</span><br><span class="line">    environmentsElement(root.evalNode("environments"));</span><br><span class="line">    databaseIdProviderElement(root.evalNode("databaseIdProvider"));</span><br><span class="line">    typeHandlerElement(root.evalNode("typeHandlers"));</span><br><span class="line">    mapperElement(root.evalNode("mappers"));</span><br><span class="line">  } catch (Exception e) {</span><br><span class="line">    throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>configuration为根节点</strong></p><h2 id="配置文件元素"><a href="#配置文件元素" class="headerlink" title="配置文件元素"></a>配置文件元素</h2><h3 id="元素properties"><a href="#元素properties" class="headerlink" title="元素properties"></a>元素properties</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--   方式一，引入外部db.properties文件 --&gt;</span><br><span class="line">&lt;properties resource="db.properties"&gt;&lt;/properties&gt;</span><br><span class="line">&lt;!--   方式二直接配置xml --&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;!-- 配置数据源 --&gt;</span><br><span class="line">    &lt;property name="driver" value="com.mysql.cj.jdbc.Driver" /&gt;</span><br><span class="line">    &lt;property name="url" value="jdbc:mysql://localhost:3306/test" /&gt;</span><br><span class="line">    &lt;property name="username" value="root" /&gt;</span><br><span class="line">    &lt;property name="password" value="123456" /&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></tbody></table></figure><p>Properties继承了Hashtable，如果同时配置2个，后加载的配置会覆盖之前的配置</p><h3 id="元素settings"><a href="#元素settings" class="headerlink" title="元素settings"></a>元素settings</h3><p>完整的setttings配置地址：<a href="https://mybatis.org/mybatis-3/zh_CN/configuration.html">https://mybatis.org/mybatis-3/zh_CN/configuration.html</a></p><h2 id="Mapper-xml文件配置"><a href="#Mapper-xml文件配置" class="headerlink" title="Mapper.xml文件配置"></a>Mapper.xml文件配置</h2><h3 id="元素cache-ref"><a href="#元素cache-ref" class="headerlink" title="元素cache-ref"></a>元素cache-ref</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace="com.read.mapper.StudentMapper"&gt;</span><br><span class="line">  &lt;!--两个 Mapper 文件将共享相同的缓存实现，避免了重复定义缓存配置的问题。--&gt;</span><br><span class="line">  &lt;cache-ref namespace="com.example.mapper.UserMapper"/&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="元素cache"><a href="#元素cache" class="headerlink" title="元素cache"></a>元素cache</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  当 blocking 属性设置为 true 时，MyBatis 使用的缓存实现（如 Ehcache）会在缓存失效时阻塞其他并发请求，</span><br><span class="line">  直到第一个线程重新查询并更新缓存，从而避免大量请求同时打到数据库上。--&gt;</span><br><span class="line">&lt;cache flushInterval="缓存刷新间隔" size="缓存的大小" eviction="缓存淘汰策略"</span><br><span class="line">       readOnly="缓存是否只读"  type="缓存类型"&gt;</span><br><span class="line">  &lt;property name="blocking" value="true"/&gt;</span><br><span class="line">&lt;/cache&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="元素resultMap"><a href="#元素resultMap" class="headerlink" title="元素resultMap"></a>元素resultMap</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">type:映射到java对象类型</span><br><span class="line">autoMapping: 是否自动映射未明确指定的字段，如果为False，只会映射resultMap中配置的字段，为True会尝试自动映射resultMap中没有配置的字段</span><br><span class="line">--&gt;</span><br><span class="line">&lt;resultMap id="studentMap" type="com.read.model.Student" autoMapping = "true"&gt;</span><br><span class="line">  &lt;!--</span><br><span class="line">    如果字段名与列名不一致，可以使用column（列名）和property（java对象字段名）</span><br><span class="line">    如果需要类型转换，可以使用 javaType（Java类型） 和 jdbcType（jdbc类型） 属性</span><br><span class="line">  --&gt;</span><br><span class="line">  &lt;result column="SId" jdbcType="VARCHAR" property="sid" /&gt;</span><br><span class="line">  &lt;result column="Sname" jdbcType="VARCHAR" property="sname" /&gt;</span><br><span class="line">  &lt;result column="Sage" jdbcType="TIMESTAMP" property="sage" /&gt;</span><br><span class="line">  &lt;result column="Ssex" jdbcType="VARCHAR" property="ssex" /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!--</span><br><span class="line">      typeHandler：处理类型转换，自定义转换类将数据库列值转换java对象字段值，或者将java对象字段值专程数据库列值</span><br><span class="line">      &lt;result column="example" property="example"  typeHandler="org.example.StringTrimTypeHandler"/&gt;</span><br><span class="line">  --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- columnPrefix 用于指定列名前缀。这在处理多表查询结果时非常有用，可以避免列名冲突 --&gt;</span><br><span class="line">  &lt;association property="address" javaType="org.example.Address" columnPrefix="address_"&gt;</span><br><span class="line">      &lt;id property="id" column="address_id"/&gt;</span><br><span class="line">      &lt;result property="street" column="address_street"/&gt;</span><br><span class="line">  &lt;/association&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- composites 用于定义复合列。复合列用于多个列值共同组成一个字段的值 --&gt;</span><br><span class="line">   &lt;result property="fullName" column="{first_name=firstName, last_name=lastName}" composites="true"/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="元素resultSet"><a href="#元素resultSet" class="headerlink" title="元素resultSet"></a>元素resultSet</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--resultSet + Collection 返回结果集：再student对象中定义List&lt;Course&gt;属性--&gt;</span><br><span class="line">    &lt;resultMap id="studentMap1" type="com.read.model.Student"&gt;</span><br><span class="line">    &lt;collection property="courses" ofType = "com.read.model.Course" resultSet="courses"&gt;</span><br><span class="line">      &lt;result column="CId" jdbcType="VARCHAR" property="cid" /&gt;</span><br><span class="line">      &lt;result column="Cname" jdbcType="VARCHAR" property="cname" /&gt;</span><br><span class="line">      &lt;result column="TId" jdbcType="VARCHAR" property="tid" /&gt;</span><br><span class="line">    &lt;/collection&gt;</span><br><span class="line">  &lt;/resultMap&gt;</span><br><span class="line">  &lt;select id="selectAll1" resultSets="Student,courses" resultMap="studentMap1"&gt;</span><br><span class="line">    select * from student where SId = #{sid}</span><br><span class="line">    select * from course where SId = #{sid}</span><br><span class="line">  &lt;/select&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="元素SQL-include-select-insert"><a href="#元素SQL-include-select-insert" class="headerlink" title="元素SQL &amp; include &amp; select &amp; insert"></a>元素SQL &amp; include &amp; select &amp; insert</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!-- id : 定义 SQL 语句的唯一标识符</span><br><span class="line">    parameterType：传递SQL语句的参数类型</span><br><span class="line">    resultType:返回结果的类型</span><br><span class="line">    resultMap:引用自定义的resultMap</span><br><span class="line">    flushCache；是否在语句执行后刷新内存</span><br><span class="line">    useCache：是否使用二级缓存</span><br><span class="line">    timeout：查询超时时间</span><br><span class="line">    fetchSize：JDBC的fetch size。类似分页。如果有1000行数据，fetchSize设置200.会执行5次，最终查到1000行数据</span><br><span class="line">    statementType：语句类型，STATEMENT：直接执行sql，不预编译；PREPARED：编译sql语句支持参数华执行，防止sql注入；CALLABLE用于调用存储过程</span><br><span class="line">    resultOrdered：结果是否有序。处理多个结果集的时候，比如resultMap 的ID为studentMap1示例 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--  SQL 片段 通过include引入--&gt;</span><br><span class="line">&lt;sql id="base_sql_column"&gt;&lt;/sql&gt;</span><br><span class="line">&lt;select id="selectAll" resultType="com.read.model.Student" parameterType="int" resultMap= "studentMap" &gt;</span><br><span class="line">  select SId,</span><br><span class="line">  &lt;include refid="base_sql_column"&gt;&lt;/include&gt; </span><br><span class="line">  from student</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">  parameterType：传递SQL语句的参数类型</span><br><span class="line">  flushCache：刷新一级缓存，如果启用了二级缓存，也会刷新</span><br><span class="line">  keyProperty(对象中的属性名)：自动生成的键值对应的属性，通常与useGeneratedKeys，keyColumn（数据库中的列名，与java对象属性不一致使用）</span><br><span class="line">  一起使用。useGeneratedKeys="true" keyProperty="sid" keyColumn="SId"插入数据后，会返回主键值。</span><br><span class="line">  databaseId：区分不同的数据库配置，实现对不同数据库系统的特定 SQL 优化或适配</span><br><span class="line">  --&gt;</span><br><span class="line">&lt;insert id="insert" parameterType="com.read.model.Student" useGeneratedKeys="true" keyProperty="sid" keyColumn="SId" &gt;</span><br><span class="line">  insert into student (SId, Sname, Sage, </span><br><span class="line">    Ssex)</span><br><span class="line">  values (#{sid,jdbcType=VARCHAR}, #{sname,jdbcType=VARCHAR}, #{sage,jdbcType=TIMESTAMP}, </span><br><span class="line">    #{ssex,jdbcType=VARCHAR})</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架｜中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议之与WEB服务器</title>
      <link href="/2024/06/05/HTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E4%B8%8EWEB%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2024/06/05/HTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E4%B8%8EWEB%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p> <strong>用单台虚拟主机实现多个域名</strong> 通过基于名称的虚拟主机配置，可以在同一个IP地址上托管多个域名。</p><h3 id="通信转发程序"><a href="#通信转发程序" class="headerlink" title="通信转发程序"></a>通信转发程序</h3><p><strong>代理</strong> ：”中间人”角色，接收由客户端发送的请求并转发给服务器，同时也接受服务器返回的响应并转发给客户端。代理不会改变请求的URLI，会直接发送给前方持有资源的目标服务器。可做到针对特定URI访问的控制。<strong>缓存代理</strong>预存副本在缓存服务器上，<strong>透明代理</strong>不对报文做任何加工。反之为<strong>非透明代理</strong>。<br><img src="/../images/1717579873084.jpg"></p><p><strong>网关</strong></p><p>利用网关可以有HTTP请求转化为其他协议通信。利用网关能提高通信的安全性。可以在客户端与网关之间通信线路上加密以确保连接的安全性。</p><p><strong>隧道</strong></p><p>隧道的目的是确保客户端能与服务器进行安全的通信。隧道本身不会去解析HTTP请求。</p><h3 id="资源缓存"><a href="#资源缓存" class="headerlink" title="资源缓存"></a>资源缓存</h3><p><strong>缓存的有效期</strong> 会确认有效性。</p><p><strong>客户端缓存</strong> 临时网络文件。会确认有效性。</p><h3 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h3><p><img src="/../images/1717586328959.jpg"></p><p><strong>HTTP首部字段</strong> ：首部字段名:字段值。<strong>类型</strong>：通用首部字段，请求首部字段，响应首部字段，实体首部字段。首部指令是可选的，多个指令之间用“，”分隔。</p><p><strong>通用首部字段</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control       制缓存的行为</span><br><span class="line">Connection          跳首部、连接的管理</span><br><span class="line">Date                创建报文的日期时间</span><br><span class="line">Transfer-Encoding   指定报文主体的传输编码方式</span><br><span class="line">Upgrade             升级为其他协议</span><br><span class="line">Via                 代理服务器的相关信息</span><br><span class="line">Warning             错误通知</span><br></pre></td></tr></tbody></table></figure><p><strong>请求首部字段</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Accept              用戶代理可处理的媒体类型</span><br><span class="line">Accept-Encoding     优先的内容编码</span><br><span class="line">Accept-Language     优先的语言(自然语言)</span><br><span class="line">Host                请求资源所在服务器</span><br><span class="line">Range               实体的字节范围请求</span><br><span class="line">User-Agent          HTTP客户端程序的信息</span><br><span class="line">Proxy-Authorization 代理服务器要求客户端的认证信息</span><br></pre></td></tr></tbody></table></figure><p><strong>响应首部字段</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges       是否接受宇节范围请求</span><br><span class="line">Age                 推算资源创建经过时间</span><br><span class="line">ETag                资源的匹配信息</span><br><span class="line">Location            令客户端重定向至指定URI</span><br><span class="line">Proxy-Authenticate  代理服务器对客户端的认证信息</span><br><span class="line">Retry-After         对再次发起请求的时机要求</span><br><span class="line">Server              HTTP服务器的安装信息</span><br><span class="line">Vary                代理服务器缓存的管理信息</span><br><span class="line">WWW-Authenticate    服务器对客户端的认证信息</span><br></pre></td></tr></tbody></table></figure><p><strong>实体首部字段</strong> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Allow               资源可支持的HTTP 方法</span><br><span class="line">Content-Encoding    实体主体适用的编码方式 </span><br><span class="line">Content-Language    实体主体的自然语言 </span><br><span class="line">Content-Length      实体主体的大小 (单位:字节) </span><br><span class="line">Content-Location    替代对应资源的URI </span><br><span class="line">Content-MD5         实体主体的报文摘要</span><br><span class="line">Content-Range       实体主体的位置范围 </span><br><span class="line">Content-Type        实体主体的媒体类型 </span><br><span class="line">Expires             实体主体过期的日期时间</span><br><span class="line">Last-Modified       资源的最后修改日期时间</span><br></pre></td></tr></tbody></table></figure><p><strong>Set-Cookie</strong>: 为Cookie服务的首部字段</p><h3 id="确保Web安全的HTTPS"><a href="#确保Web安全的HTTPS" class="headerlink" title="确保Web安全的HTTPS"></a>确保Web安全的HTTPS</h3><p><strong>HTTP缺点</strong> 通信使用明文(不加密)，内容可能会被窃听；不验证通信方的身份， 因此有可能遭遇伪装；无法证明报文的完整性，所以有可能已遭篡改。</p><p><strong>HTTPS</strong> HTTP协议中没有加密机制，但可以通过和SSL或者TLS的组合使用，加密HTTP的通信内容（<strong>通信加密</strong>）。</p><p><strong>内容加密</strong> HTTP协议中没有加密机制，那么就对HTTP协议传输的内容本身加密。对报文主体加密。前提是要求客户端和服务端同时具备加密和解密机制。能有可能被篡改。</p><p><strong>不验证通信方的身份就可能遭遇伪装</strong> ：任何人都可以发起请求。<br><strong>无法证明报文完整性，可能已被篡改</strong> ：接收到的内容可能有误<br><strong>如何防止篡改</strong> ：常用的方法是MD5 和SHA-1等散列值集校验以及用来确认文件的数字签名方法。因为PGP 和MD5 本身被改写的话，用户是没有办法意识到的。用这些方法也依然无法百分百保证确认结果正确。为了有效防止这些弊端， 有必要使用<strong>HTTPS</strong>。</p><p><strong>HTTP+加密+认证+完整性保护 = HTTPS</strong> ： HTTPS是身披SSL外壳的HTTP，只是HTTP通信接口部分用SSL和TLS协议代替，通常HTTP直接和TCP通信，当使用SSL时则先和SSL通信，再有SSL和TCP通信。<br><img src="/../images/1717636990962.jpg"></p><p>SSL采用公开密钥加密，密钥是保密的。<strong>共享密钥加密</strong> 加密和解密同用一个密钥。也称为对称密钥加密。发送密钥就有被窃听的风险，但不发送，对方就不能解密。再说，密 钥若能够安全发送，那数据也应该能安全送达。<strong>公开密钥加密</strong>很好解决了共享密钥加密的困难。公开密钥加密使用非对称的密钥，一吧叫做私有密钥，一把叫做公开密钥。使用密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再用私有密钥解密。这样既不需要发送私有密钥，也不必担心密钥被攻击盗走。HTTPS采用的<strong>混合加密</strong>：使用公开密钥加密 加密 共享密钥方式中的密钥，确保安全的情况下，使用共享密钥加密方式进行通信。</p><h3 id="Session管理及Cookie应用"><a href="#Session管理及Cookie应用" class="headerlink" title="Session管理及Cookie应用"></a>Session管理及Cookie应用</h3><p>基于表单认证是通过服务器端的Web应用，将客户端发送来的用户Id和密码与之前登陆过的信息做匹配来进行认证。HTTP是无状态协议，于是会使用Coolie来管理Session，来弥补HTTP协议中不存在的状态管理功能。<br><img src="/../images/1717641701756.jpg"><br>1、客户端发送用户ID和密码等登录信息到服务器<br>2、服务器发放用以识别用户的SessionId，返回是会在首部字段Set-Cookie写入SessionId<br>3、客户端收到服务器端发来的Session ID后，将其作为Cookie保存在本地。下次发送请求时，浏览器或自动发送Cookie。</p><p><strong>加盐</strong>：一种安全的保存密码方法，先利用给密码加盐的方式增加额外信息，在使用散列函数计算出散列值后保存。</p><h3 id="HTTP瓶颈"><a href="#HTTP瓶颈" class="headerlink" title="HTTP瓶颈"></a>HTTP瓶颈</h3><p>使用HTTP协议探知服务器上是否有内容更新，就必须频繁的从客户端到服务端进行确认。（1、不管是否有更新都要吧数据全部响应一次。2、每次互相发送相同的首部。3、有时不压缩数据直接发送）。</p><p><strong>Ajax</strong> 有效利用JavaScript和DOM的操作，以达到局部Web页面替换加载的异步通信手段。但是并没有解决HTTP协议本身的问题。</p><h3 id="全双工通信的WebSocket"><a href="#全双工通信的WebSocket" class="headerlink" title="全双工通信的WebSocket"></a>全双工通信的WebSocket</h3><p>WebSocket，即Web浏览器与Web服务器之间全双工通信标准。</p><p>一旦建立WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可以互次昂发送JSON，XML或图片等任意格式的数据。</p><p><strong>WebSocket协议</strong> 主要特点：<br>推送功能：支持由服务器向客户端推送数据的推送功能。<br>减少通信量：只要建立起WebSocket 连接，就希望一直保持连接状态。位了实现WebScoket通信，在HTTP连接建立之后，需要完成一次握手的步骤。成功握手确立WebScoket连接之后，通信时不再使用HTTP的数据帧，而采用WebSocket独立的数据帧。<br><img src="/../images/1717665892946.jpg"></p><h3 id="Web攻击技术"><a href="#Web攻击技术" class="headerlink" title="Web攻击技术"></a>Web攻击技术</h3><p>简单的HTTP协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击的对象。应用HTTP协议的服务器和客户端，以及运行在服务器上的web应用等资源才是攻击目标。</p><p><strong>在客户端即可篡改请求</strong></p><p><strong>针对Web应用的攻击模式</strong><br>主动攻击：<br><img src="/../images/1717667317285.jpg"><br>被动攻击：具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。<br><img src="/../images/1717667403282.jpg"></p><p><strong>利用用户的身份攻击企业内部的网络</strong><br>利用被动攻击，可发起对原本从互联网上无法直接访问的企业内网等网络的攻击。</p><p><strong>跨站脚本攻击</strong> 跨站脚本政击(Cross-SiteScripting，XSS)是指通过存在的安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。XSS是攻击者利用预先设置的陷阱触发的被动攻击。</p><p><strong>SQL注入攻击</strong></p><p><strong>OS命令注入攻击</strong></p><p><strong>HTTP首部注入攻击</strong></p><p><strong>HTTP响应截断攻击</strong></p><p><strong>邮件首部注入攻击</strong></p><p><strong>远程文件包含漏洞</strong></p><p><strong>开放重定向</strong> 是一种对指定的任意URL作重定向<br>跳转的功能。而于此功能相关联的安全漏洞是指，假如指定的重定向URL到某个具有恶意的Web网站，那么用户就会被诱导至那个Web网站。</p><p><strong>会话劫持</strong> 会话劫持(Session Hiack )是指攻击者通过某种手段拿到了用户的<br>会话1D，并非法使用此会话1D 份装成用户，达到攻击的目的。</p><p><strong>会话固定攻击</strong>对以窃取目标会话ID为主动攻击手段的会话劫持而言，会话固定攻击(Sesion Fixation )攻击会强制用户使用攻击者指定的会话ID，属于被动攻击。</p><p><strong>跨站点请求伪造</strong> 可能造成的问题：<br>• 利用己通过认证的用户权限更新设定信息等<br>• 利用己通过认证的用户权限购买商品<br>• 利用己通过认证的用户权限在留言板上发表言论</p><p><strong>点击劫持</strong><br>点击劫持是指利用透明的按钮或链接做成陷阱，覆盖在web页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装。</p><p><strong>DOS攻击</strong> DOS攻击是一种让运行中的服务呈停止状态的攻击。</p><p><strong>后门程序</strong> 后门程序(Backdoor )是指开发设置的隐藏入口，可不按正常步骤使用受限功能。可通过监视进程和通信的状态发现被植人的后门程序。但设定在 web 应用中的后门程序，由于和正常使用时区别不大，通常很难发现。</p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议之详情</title>
      <link href="/2024/06/04/HTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E8%AF%A6%E6%83%85/"/>
      <url>/2024/06/04/HTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E8%AF%A6%E6%83%85/</url>
      
        <content type="html"><![CDATA[<p>HTTP报文大致分为报文首部和报文主体两块。[ <strong>报文首部</strong>]服务器端或者客户端需要处理的请求或响应的内容及属性。[ <strong>CR+LF</strong>]空行，[ <strong>报文主体</strong>]应被发送的数据。<br><img src="/../images/%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.jpg"></p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="提升传输效率"><a href="#提升传输效率" class="headerlink" title="提升传输效率"></a>提升传输效率</h3><p><strong>压缩传输的内容编码</strong>：如邮件添加附件（压缩附件）。常用的内容编码：gzip，compress(UNIX系统标准压缩)，deflate(zlib),identity(不进行编码)。<br><strong>分割发送的分块传输编码</strong>：chunked(Content-Length:null Transfer-Encoding:chunked) 把实体主体分块的功能。HTTP/1.1中存在一种称为传输编码的机制。HTTP/2 中已经不支持 chunked 这一格式了，因为其本身提供了更加高级的流机制来实现类似功能.</p><h3 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h3><p>HTTP协议中也采纳了多部分对象集合，发送一份报文主体内可以包含多种类型的实体。通常是在图片或者文本文件等上传时使用。<strong>multipart/form-date</strong>在web表单文件上传时使用。<strong>nultipart/byteranges</strong>状态码206，响应报文包含多个范围的内容时使用。</p><h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>解决网络中断，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处回复下载。实现该功能需要指定下载的范围实体(<strong>范围请求</strong>)。使用范围请求时，会用到首部字段Range来指定资源的byte范围。<br><img src="/../images/%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82.jpg"></p><h3 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h3><p>内容协商机制是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。聂荣协商会以响应资源的语言，字符集，编码方式等作为判断基准。<strong>服务器驱动协商</strong>，<strong>客户端驱动协商</strong>，<strong>透明协商</strong></p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1XX -&gt; 信息性状态码 -&gt; 接收的请求正在处理</span><br><span class="line">2XX -&gt; 成功状态码 -&gt; 请求正常处理完毕</span><br><span class="line">    200 OK</span><br><span class="line">    204 No Content</span><br><span class="line">    206 Partial Content 范围请求你</span><br><span class="line">3XX -&gt; 重定向状态码 -&gt; 需要进行附加操作以完成请求</span><br><span class="line">    301 Moved Permanently 永久性重定向</span><br><span class="line">    302 Found 临时性重定向</span><br><span class="line">    303 See Other 该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源</span><br><span class="line">    304 </span><br><span class="line">    307</span><br><span class="line">4XX -&gt; 客户端错误状态码 -&gt; 服务器无法处理请求</span><br><span class="line">    400 Bad Request 表示请求报文存在语法错误</span><br><span class="line">    401 Unauthorized 发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息</span><br><span class="line">    403 Forbidden 对请求资源的访问被服务器拒绝了</span><br><span class="line">    404 Not Found 服务器没有请求的资源</span><br><span class="line">5XX -&gt; 服务器错误状态码 -&gt; 服务器处理请求出错</span><br><span class="line">    500 服务器端在执行请求发生了错误</span><br><span class="line">    503 服务器暂时处于超负载或者正在停机维护 </span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议之基础</title>
      <link href="/2024/06/03/HTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/06/03/HTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>HTTP 是一种用作获取诸如 HTML 文档这类资源的协议。它是 Web 上进行任何数据交换的基础，同时，也是一种客户端—服务器（client-server）协议，也就是说，请求是由接受方——通常是浏览器——发起的。一个完整网页文档是由获取到的不同文档组件——像是文本、布局描述、图片、视频、脚本等——重新构建出来的。<br><img src="/../images/HTTP%E6%A6%82%E8%BF%B0.jpg" alt="HTTP协议之基础"></p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="1、网络基础"><a href="#1、网络基础" class="headerlink" title="1、网络基础"></a>1、网络基础</h3><p>&nbsp;&nbsp;TCP/IP协议族是各类互联网相关的各类协议族的总称。TCP/IP协议族最重要的就是分层：应用层，传输层，网络层，数据链路层。</p><p><strong>应用层</strong>：应用层决定了向用户提供应用服务时通信的活动。TCP/IP协议族内预存了各类通用的应用服务。比如HTTP协议,FTP(文件传输协议)，DNS(域名服务)。</p><p><strong>传输层</strong>：传输层对上层应用，提供处于网络连接中的两台计算机的网络传输。在传输层有两个性质不同的协议：TCP(传输控制协议)，UDP(用户数据报协议)。</p><p><strong>网络层</strong>：网络层是用来处理网络上流动的数据包。数据包是网络传输的最小数据单位，该层规定了通过怎样的路径，到达对应的计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或者网络设备进行传输时，网络层所起的作用就是在众多的选项中选择一条传输路线。</p><p><strong>链路层（网络接口层）</strong>：用来处理网络的硬件部分。包括控制操作系统，硬件的设备驱动，NIC(网络适配器：网卡)及光线等物理可见部分，硬件的范畴均在链路层的作用范围之内。</p><p><img src="/../images/%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E6%B5%81.jpg" alt="TCP/IP通信传输流"></p><p><strong>负责传输的IP协议</strong>：IP地址指明了节点被分配的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对，IP地址可更换，但MAC地址基本上不会改变。IP间的通信依赖MAC地址，在网络上，通常是经过多台计算机和网络设备中转才能连接到对方，在中转过程中会利用下一站的MAC地址来搜索下一个中转目标。会采用<strong>ARP协议</strong>，ARP协议是一种用来解析地址的协议。根据通信方的IP地址就可以查出对应的MAC地址。</p><p><strong>可靠的TCP协议</strong>：TCP位于传输层，提供可靠的字节流服务。字节流服务是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠的传给对方。为了准确无误将数据送达目标，TCP协议采用了三次握手策略。<br><img src="/../images/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%AE%80.jpg" alt="三次握手（简）"></p><p><strong>域名解析DNS服务</strong>：和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。<br><img src="/../images/%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt="与HTTP关系图"></p><h3 id="2、简单的HTTP协议"><a href="#2、简单的HTTP协议" class="headerlink" title="2、简单的HTTP协议"></a>2、简单的HTTP协议</h3><p>HTTP协议和TCP/IP协议族内的其他众多的协议相同，用于客户端和服务器之间的通信。HTTP是一种不保存协议，即<strong>无状态协议</strong>。HTTP协议自身不对请求和响应之间的通信状态进行保存。HTTP/1.1虽然也是无状态协议，但是为了实现期望的保存状态功能，引入了Cookie技术。</p><p>HTTP/1.1方法 –&gt;<br>&nbsp;&nbsp;&nbsp; <strong>GET</strong>:获取资源<br>&nbsp;&nbsp;&nbsp; <strong>POST</strong> 传输实体主体<br>&nbsp;&nbsp;&nbsp; <strong>PUT</strong>：传输文件<br>&nbsp;&nbsp;&nbsp; <strong>HEAD</strong>：获得报文首部（不返回报文主体部分）<br>&nbsp;&nbsp;&nbsp; <strong>DELETE</strong>：删除文件<br>&nbsp;&nbsp;&nbsp; <strong>OPTIONS</strong>：询问支持的方法（如支持GET和HEAD方法）<img src="/../images/OPTIONS%E6%96%B9%E6%B3%95.jpg"><br>&nbsp;&nbsp;&nbsp; <strong>TRACE</strong>：追踪路径（不常用，容易引发SXST攻击）<br>&nbsp;&nbsp;&nbsp; <strong>CONNECT</strong>：要求用隧道协议连接代理，要求在代理服务器通信时建立隧道，实现隧道协议惊醒TCP通信。主要使用SSL(安全套阶层)和TLS(传输层安全)协议把通信内容加密后经过网络隧道传输。格式：CONNECT 代理服务器名:端口号 HTTP版本 。场景：HTTPS代理，防火墙和安全网关，VPN服务等</p><p>在HTTP/1.1中，所有的连接默认都是持久连接（长连接），在HTTP/1.0还没有标准化。持久化连接是的多数请求翼<strong>管线化</strong>(pipelining)方式发送层成为可能。从前发送请求后需要等待并收到响应，才能发送下一个请求。管线化技术出现后，不能等待响应可以直接发送下次请求。</p><p><strong>Cookie状态管理</strong>：Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部信息，通知客户端保存Cookie。当客户端再次发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。<br><img src="/../images/Cookie%E4%BA%A4%E4%BA%92.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql记录存储结构</title>
      <link href="/2024/06/01/Mysql%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
      <url>/2024/06/01/Mysql%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>服务器程序在处理来自客户端的查询请求时，大致需要分为3部分：连接管理，解析与优化，存储引擎。<br><img src="/../images/1717725217845.jpg"></p><h2 id="InnoDB记录存储结构"><a href="#InnoDB记录存储结构" class="headerlink" title="InnoDB记录存储结构"></a>InnoDB记录存储结构</h2><p><strong>InnoDB行</strong> : InnoDB存储引擎有4种不同类型的行格式。分别是COMPACT，REDUNDANT，DYNAMIC，COMPRESSED。</p><h3 id="InnoDB-COMPACT行格式"><a href="#InnoDB-COMPACT行格式" class="headerlink" title="InnoDB-COMPACT行格式"></a>InnoDB-COMPACT行格式</h3><p><img src="/../images/COMPACT%E8%A1%8C%E6%A0%BC%E5%BC%8F.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table record_format_demo(</span><br><span class="line">    c1 varchar(10),</span><br><span class="line">    c2 varchar(10) not null,</span><br><span class="line">    c3 char(10),</span><br><span class="line">    c4 varchar(10)</span><br><span class="line">) charset=ascii row_format = compact;</span><br><span class="line"></span><br><span class="line">insert into record_format_demo (c1,c2,c3,c4)values('aaaa','bbb','cc','d'),('eeee','fff',NULL,NULL);</span><br></pre></td></tr></tbody></table></figure><p><strong>1、变长字段长度列表</strong><br>分为2部分：1、真正的数据内容；2、该数据占用的字节数。变长字段字节是按照逆序排列。</p><blockquote><p>★ 并不是所有记录都有这个变长字段长度列表部分，如果表中所有的列都不是变长数据类型或者所有的值都是NULL的话，就不需要变长字段长度列表。<br>★ 引入W字节来表示一个字符，utf8mb4字符集种W=4，utf8字符集中W=3,gbk字符集中W=2；引入M表示字符；引入L表示实际存储的字节数；对于VARCHAR(M)来说，最多占用字节数就是M * W。<br>★ <strong>长度前缀</strong>使用1个字节表示，还是用2个字节表示。规则如下：</p><blockquote><p>如果M * W &lt;= 255,那么使用一个字节的长度前缀。<br>如果M * W &gt;= 255,则又分2种情况：1、如果L &lt;= 127 则用1个字节的长度前缀；2、如果 L &gt; 127 ,则用2个字节的长度前缀。</p></blockquote></blockquote><p><strong>2、NULL值列表</strong></p><blockquote><p>★ 只通知允许为存储NULL的列。<br>★ 如果表中没有允许存储NULL的列，则NULL值列表就不存在了。<br>★ NULL值标志位用二进制记录，按照列的顺序逆序排列。值为1时，代表为NULL，为0时，代表不为NULL。</p></blockquote><p><strong>3、记录头信息</strong></p><blockquote><p>★由固定的5个字节组成，也就是40位二进制组成。<br><img src="/../images/compact-%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF.png"></p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">预留位1                  1位             没有使用    </span><br><span class="line">预留位2                  1位             没有使用    </span><br><span class="line">deleted_flag            1位             标记是否被删除</span><br><span class="line">min_rec_flag            1位             最小记录标记，通常用来标记页面中的最小记录(索引优化，快速定位最小记录)</span><br><span class="line">n_owned                 4位             用于表示当前记录拥有记录槽(solt)的数量，这些槽可以用来存储实际的记录数据</span><br><span class="line">                                            也可以用来管理页中自由空间：管理记录链表，优化页面存储</span><br><span class="line">heap_no                 13位            标识记录在页中的位置，它是记录在数据页中的唯一标识符，可以帮助快速定</span><br><span class="line">                                            位特定记录； 来管理和组织页中的记录。它在记录的插入、更新和删除操作中起到关键作用；  有助于页内记录的排序和管理。</span><br><span class="line">record_type             3位             区分记录类型： 0 (ORDINARY_RECORD)：普通记录，表示实际的用户数据记录</span><br><span class="line">                                                    1 (NODE_POINTER)：节点指针，表示B+树中指向子节点的指针记录。</span><br><span class="line">                                                    2 (INFIMUM)：页的最小记录（infimum record），用于页的边界管理。</span><br><span class="line">                                                    3 (SUPREMUM)：页的最大记录（supremum record），用于页的边界管理。</span><br><span class="line">next_record             16位            用于指向下一条记录(表示下一条记录的相对位置)；用途：顺序扫描；范围查询；</span><br><span class="line">                                            插入和删除操作</span><br></pre></td></tr></tbody></table></figure><p><img src="/../images/COMPACT%E8%AF%A6%E7%BB%86.png"></p><p><strong>4、记录的真实数据</strong></p><p>mysql会为每个记录默认添加一些列（隐藏列）DB_ROW_ID,DB_TRX_ID,DB_ROLL_PTR。<br>InnoDB主键生成策略：  1、优先使用自定义主键；2、其次不允许为空的UNQUE（唯一）键作为主键；3、最后默认添加row_id的隐藏列作为主键</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">列名            是否必需        占用字节            描述</span><br><span class="line">row_id          否              6字节           行ID，唯一标识</span><br><span class="line">trx_id          是              6字节           事务ID</span><br><span class="line">roll_pointer    是              7字节           回滚指针</span><br></pre></td></tr></tbody></table></figure><p>CHAR(M)类型是定长，不属于变长字段，不会记录到变长字段长度列表中。</p><h3 id="InnoDB-REDUNDANT行格式"><a href="#InnoDB-REDUNDANT行格式" class="headerlink" title="InnoDB-REDUNDANT行格式"></a>InnoDB-REDUNDANT行格式</h3><p>REDUNDANT行格式是mysql5.0之前就在使用的一种行格式。<br><img src="/../images/REDUNDANT%E8%A1%8C%E6%A0%BC%E5%BC%8F.png"></p><p><strong>1、字段长度偏移列表</strong></p><p>REDUDANT行格式会把记录中<strong>所有的</strong>列的长度信息都按照逆序存储到字段长度偏移列表中。而且采用两个相邻偏移量的差值来计算各个列的长度。<br>也是逆序排列</p><p>与COMPACT行格式相比，REDUNDANT行格式多了n_field和1byte_offs_flag这两个属性；没有record_type这个属性。</p><p>REDUNDANT行格式没有NULL值列表：在字段长度偏移列表中对各列对应的偏移量做了特殊处理—将对应的偏移量值的第一位作为是否为NULL的依据，也称为NULL值比特位。如果该值为1，该列就为NULL。</p><p>如果存储的NULL值字段是定长字段，则NULL值也将占用记录的真实数据部分；如果存储的NULL值字段是变长数据类型，则不在记录的真实数据部分占用任何存储空间。</p><h3 id="溢出列"><a href="#溢出列" class="headerlink" title="溢出列"></a>溢出列</h3><p>InnoDB中磁盘和内存交互的基本单位是页。也就是说InnoDB是以页为基本单位来管理存储空间的。一个页的大小一般是16kb。在COMPACT和REDUNDANT行格式中，对于占用存储空间非常多的列。在记录真实数据处只会存储该列的一部分数据，而把<strong>剩余的数据分散存储到几个其他的页</strong>中。然后在记录真实数据处用20字节存储指向这些页的<strong>地址</strong>（还有存粗在其他页数据的<strong>字节数</strong>）。</p><p><img src="/../images/%E6%BA%A2%E5%87%BA%E9%A1%B5.png"></p><p><strong>一个列存储多少字节之后会变成溢出列呢？</strong> 一个页默认16kb也就是16384字节，mysql中规定一个页中至少存放2行数据。<br>1、除了存放记录外，还需要存储一些额外的信息。共132字节空间。<br>2、每个记录需要额外信息是27个字节：2字节存储真实数据长度；1字节存储NULL值；5个字节存储头信息；6个字节的Row_id列；6字节的trx_id列；7字节的roll_pointer列。假设一个列的真实数据占用的字节数为n：如果该列不发生溢出现象，就需要满足不等式：132+2*(27+n)&lt;16384。</p><p><strong>mysql版本5.7之后，默认使用DYNAMIC行格式</strong> ，DYNAMIC行格式和COMPRESSED行格式与COMPACT类似：但是处理<strong>溢出列不同</strong>：DYNAMIC行格式不会存储真实数据，而是把所有的真实数据都存储到溢出页中。只记录真实数据处存储20字节大小的指向溢出页的地址。COMPRESSED行格式会采用压缩算法对页面进行压缩。以节省空间。</p><p><strong>REDUNDANT是一种比较原始的韩格式，非紧凑型。而DYNAMIC，COMPACT，COMPRESSED 是较新的行格式，紧凑型(占用存储空间更少)</strong></p><h2 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h2><p><img src="/../images/%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84.png"></p><h3 id="记录存储"><a href="#记录存储" class="headerlink" title="记录存储"></a>记录存储</h3><p>第二条记录被标记为删除，将被删除的记录加入到垃圾链表中是2个阶段。多条被删除的记录next_record会形成垃圾链表。<br>Infimum记录和Supremum记录没有主键，Infimum记录是页面中最小的记录，Supremum记录是页面中最大的记录。<br>堆中的Heap_no值被分配之后就不会再改变，即使删除了某条记录也不会变。<br>next_record属性，箭头总是指向下一条记录的头记录和真实数据中间位置（<strong>紫色箭头</strong>），因为记录头逆序排列，向左读区是记录头信息，向右读区是真实数据。变长字段长度列表，null列表都是逆序排列，记录中靠前的字段和对应的字段信息在内存中更近，提高缓存命中率。<br>被删除的记录不会再被上一条记录指向（<strong>红色箭头</strong>）</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E9%A1%B5%E2%80%94%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF.png"></p><h3 id="页目录"><a href="#页目录" class="headerlink" title="页目录"></a>页目录</h3><p>将所有的记录(除去已经移除到垃圾链表的记录)划分为组，将每组中最后一条记录在页面只能够的地址偏移量（该记录真实数据与页面第0个字节之间的距离）单独提取出来（带头大哥属性n_owned为该组中记录数量），按照顺序存储到靠近尾部的地方。这个就是Page Directory（页目录）。页中这些地址偏移量称为槽（Slot），每个槽占用2个字节，页目录就是由多个槽组成的。</p><p>每个分组中记录条数<strong>规定</strong>：Infimum记录所在的分组只能有一条记录。Supremum记录所在的分组拥有的记录条数只能在1～8条之间。其他的分组中记录的条数范围只能在4～8条之间。</p><blockquote><p>1、初始情况，一个页只有Infimum和Supremum记录，也就是2个分组。<br>2、每插入一条记录。都会从页目录中找到对应记录的主键值比待插入记录主键值大并且差值最小的槽。然后把对应槽的n_owned加1.直到改组中记录数等于8.<br>3、当一个组中的数据等于8之后，再插入记录，会将组中的记录拆分成2个组。拆分过程中新增一个槽。</p></blockquote><h3 id="页面头部"><a href="#页面头部" class="headerlink" title="页面头部"></a>页面头部</h3><p>Page Header 占用固定56个字节，专门存储各种状态信息。比如数据也中存了多少记录，Free Space字页面中的地址偏移量，也目录中存储了多少槽等。</p><blockquote><p>PAGE_N_DIR_SLOTS       2字节       在页目录中的槽数量<br>PAGE_HEAP_TOP           2字节       还未使用的空间最小地址，从改地址之后就是Free Space<br>PAGE_N_HEAP             2字节       第一位表示是否为紧凑型，后15位表示本页中的堆中记录的数量<br>PAGE_FREE               2字节       各个已删除的记录通过next_record组成一个单向链表，这个单向链表中记录的所占用的存储空间可<br>                                        以被重新利用。PAGE_FREEbao表示该链表头节点对应记录在页面中的偏移量。<br>PAGE_GARBAGE            2字节       已删除记录占用的字节数<br>PAGE_LAST_INSERT        2字节       最后插入记录的位置<br>PAGE_DIRECTION          2字节       记录插入的方向<br>PAGE_N_DIRECTION        2字节       一个方向连续插入的记录数量<br>PAGE_N_RECS             2字节       该也中用户记录的数量<br>PAGE_MAX_TRX_ID         2字节       修改当前页面的最大事物ID，仅存在二级索引页面中定义<br>PAGE_LEVEL              2字节       当前页在B+数中所处的层级<br>PAGE_INDEX_ID           8字节       索引ID，表示当前页属于那个索引<br>PAGE_BTR_SRE_LEAF       10字节      B+数也字节点段的头部信息，仅在B+数的根页面中定义<br>PAGE_BTR_SEG_TOP        2字节       B+数非叶字节点段的头部信息，仅存在B+数的根页面中定义</p></blockquote><h3 id="文件头部"><a href="#文件头部" class="headerlink" title="文件头部"></a>文件头部</h3><p><strong>File Header</strong>部分占用固定38字节，描述一些通用于各种页的信息，不如页扽编号，上一个页和下一个页面等等。</p><p><strong>各种页面的类型</strong>：</p><blockquote><p>FILE_PAGE_TYPE_ALLOCATED           最新分配，还未使用<br>FIL_PAGE_UNDO_LOG                   undo日志页<br>FIL_PAGE_INODE                      存储段的信息<br>FIL_PAGE_IBUG_FREE_LIST             Change Buffer空闲列表<br>FIL_PAGE_IBUF_BITMAP                Change Buffer的一些属性<br>FIL_PAGE_TYPE_SYS                   存储一些系统数据<br>FIL_PAGE_TYPE_TRX_SYS               事务系统数据<br>FIL_PAGE_TYPE_FSP_HDR               表空间头部信息<br>FIL_PAGE_TYPE_FSP_HDR               存储区的一些属性<br>FIL_PAGE_TYPE_BLOB                  溢出页<br>FIL_PAGE_INDEX                      索引页（数据页）</p></blockquote><p><strong>存储记录的数据页面是可以组成一个双向链表</strong></p><h3 id="文件尾部"><a href="#文件尾部" class="headerlink" title="文件尾部"></a>文件尾部</h3><p>File Trailer由8个字节组成。用于校验页是否完整。</p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
